{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP 4768: Software Development for Mobile Devices Instructor: Pranjal Patra Office: EN2008 Email: pp7002@mun.ca Office Hours: Fridays 2PM to 4PM or by request (virtual meetings) Evaluation Assignments (4 - 5): 50% Project: 50% Representative Course Outline (Tentative) Module 0: Intro, Setup, Hello World 0.0: Course Introduction 0.1: Setup and creating a flutter project 0.2: Hello World in flutter Module 1: Flutter 101: 1.0: First Flutter app 1.1: What is State? 1.2: Managing State in Flutter 1.3: Common Widgets 1.4: Routing 1.5: Layouts Module 2: Dart: 2.1 Introduction to Dart 2.2 Syntax Basics 2.3 Types 2.4 Functions 2.5 Loops and Branches 2.6 Error Handling 2.7 OOP 2.8 Concurrency 2.9 Null Safety Module 3: More Flutter Topics: 3.0 Animation 3.1 Design and Theming 3.2 Navigation and Routing 3.3 Persistence 3.4 Miscellaneous Topics in Flutter Module 4: Firebase 4.0 Firebase Authentication 4.1 Firebase CRUD Module 5: Capstone Project Course Description focuses on the design and implementation of software in a mobile networking environment. The primary topics to be covered in this course include software engineering, network computing, graphics programming, and human-computer interaction for mobile devices. A modern mobile device with advanced networking and graphic features, including multi-touch interaction and motion sensors will be used as the primary platform for development in this course. Prerequisites COMP 2008 or the former COMP 2760 COMP 2006 or the former COMP 3715 COMP 2005 or the former COMP 3716 Additional Policies: Mode of Delivery: In-person Course Format: Lecture-based Method of Instructional Continuity: In the case of a class disruption or cancellation, and in the case of revisions to evaluation methods, the instructor or the Head of the department will notify all students registered in the course via the course shell in Brightspace. Any necessary revisions to the evaluation methods will be made in consultation with the students registered in this course. If a student demonstrates that they would be disadvantaged by the change, then, as per 6.7.4 of the University Calendar, accommodations will be made. Memorial University of Newfoundland is committed to fostering equitable and accessible learning environments for all students. Accommodations for students with disabilities are provided in accordance with Accommodations for Students with Disabilities Policy (www.mun.ca/policy/site/policy.php?id=239) and its related procedures. Students who feel that they may require formal academic accommodations to address barriers or challenges they are experiencing related to their learning are encouraged to contact Accessibility Services (the Blundon Centre) at the earliest opportunity to ensure any required academic accommodations are provided in a timely manner. You can contact Accessibility Services (Blundon Centre) by emailing blundon@mun.ca. Students are expected to adhere to those principles which constitute proper academic conduct. A student has the responsibility to know which actions, as described under Academic Offences in the University Regulations, could be construed as dishonest or improper. Students found guilty of an academic offence may be subject to a number of penalties commensurate with the offence including reprimand, reduction of grade, probation, suspension or expulsion from the University. For more information regarding this policy, students should refer to the University Regulations for Academic Misconduct (Section 6.12) in the University Calendar What is academic integrity?","title":"COMP 4768: Software Development for Mobile Devices"},{"location":"#comp-4768-software-development-for-mobile-devices","text":"","title":"COMP 4768: Software Development for Mobile Devices"},{"location":"#instructor-pranjal-patra","text":"Office: EN2008 Email: pp7002@mun.ca Office Hours: Fridays 2PM to 4PM or by request (virtual meetings)","title":"Instructor: Pranjal Patra"},{"location":"#evaluation","text":"Assignments (4 - 5): 50% Project: 50%","title":"Evaluation"},{"location":"#representative-course-outline-tentative","text":"Module 0: Intro, Setup, Hello World 0.0: Course Introduction 0.1: Setup and creating a flutter project 0.2: Hello World in flutter Module 1: Flutter 101: 1.0: First Flutter app 1.1: What is State? 1.2: Managing State in Flutter 1.3: Common Widgets 1.4: Routing 1.5: Layouts Module 2: Dart: 2.1 Introduction to Dart 2.2 Syntax Basics 2.3 Types 2.4 Functions 2.5 Loops and Branches 2.6 Error Handling 2.7 OOP 2.8 Concurrency 2.9 Null Safety Module 3: More Flutter Topics: 3.0 Animation 3.1 Design and Theming 3.2 Navigation and Routing 3.3 Persistence 3.4 Miscellaneous Topics in Flutter Module 4: Firebase 4.0 Firebase Authentication 4.1 Firebase CRUD Module 5: Capstone Project","title":"Representative Course Outline (Tentative)"},{"location":"#course-description","text":"focuses on the design and implementation of software in a mobile networking environment. The primary topics to be covered in this course include software engineering, network computing, graphics programming, and human-computer interaction for mobile devices. A modern mobile device with advanced networking and graphic features, including multi-touch interaction and motion sensors will be used as the primary platform for development in this course.","title":"Course Description"},{"location":"#prerequisites","text":"COMP 2008 or the former COMP 2760 COMP 2006 or the former COMP 3715 COMP 2005 or the former COMP 3716","title":"Prerequisites"},{"location":"#additional-policies","text":"Mode of Delivery: In-person Course Format: Lecture-based Method of Instructional Continuity: In the case of a class disruption or cancellation, and in the case of revisions to evaluation methods, the instructor or the Head of the department will notify all students registered in the course via the course shell in Brightspace. Any necessary revisions to the evaluation methods will be made in consultation with the students registered in this course. If a student demonstrates that they would be disadvantaged by the change, then, as per 6.7.4 of the University Calendar, accommodations will be made. Memorial University of Newfoundland is committed to fostering equitable and accessible learning environments for all students. Accommodations for students with disabilities are provided in accordance with Accommodations for Students with Disabilities Policy (www.mun.ca/policy/site/policy.php?id=239) and its related procedures. Students who feel that they may require formal academic accommodations to address barriers or challenges they are experiencing related to their learning are encouraged to contact Accessibility Services (the Blundon Centre) at the earliest opportunity to ensure any required academic accommodations are provided in a timely manner. You can contact Accessibility Services (Blundon Centre) by emailing blundon@mun.ca. Students are expected to adhere to those principles which constitute proper academic conduct. A student has the responsibility to know which actions, as described under Academic Offences in the University Regulations, could be construed as dishonest or improper. Students found guilty of an academic offence may be subject to a number of penalties commensurate with the offence including reprimand, reduction of grade, probation, suspension or expulsion from the University. For more information regarding this policy, students should refer to the University Regulations for Academic Misconduct (Section 6.12) in the University Calendar What is academic integrity?","title":"Additional Policies:"},{"location":"0.0_course_intro/","text":"","title":"0.0 Course Introduction"},{"location":"0.1_getting_started/","text":"Get Started with Flutter Install Flutter SDK This part guides you through the installation process of Flutter on your computer. You'll download the Flutter SDK and update the $PATH variable to include the flutter/bin directory. Follow the guide created for your OS. Install an editor In this section, you'll learn how to set up a code editor for Flutter development. Popular choices include VS Code and Android Studio. I will be using Android Studio in class and if like to follow along, I suggest the same IDE. Run flutter doctor You should get something like this after you install everything. Output will look different based if you are on Windows or Linux, but you should have atleast one simulator working (andoroid or iOS) and also Chrome should work Test Drive This part helps you get hands-on experience by walking you through creating, running, and modifying a simple Flutter app. Create the app Here, you'll create a new Flutter project using the command line or your chosen editor's interface. Run the app This step shows you how to run your Flutter app on a physical device or an emulator. Hot reload Learn about Flutter's hot reload feature, which allows you to see changes instantly without rebuilding the entire app. Run on multiple platforms Run your app in a variety of platforms such as: iOS simulator Android simulator Windows MacOS Linux Chrome/Edge You can also try running on a physical device","title":"0.1 Getting Started"},{"location":"0.1_getting_started/#get-started-with-flutter","text":"","title":"Get Started with Flutter"},{"location":"0.1_getting_started/#install-flutter-sdk","text":"This part guides you through the installation process of Flutter on your computer. You'll download the Flutter SDK and update the $PATH variable to include the flutter/bin directory. Follow the guide created for your OS.","title":"Install Flutter SDK"},{"location":"0.1_getting_started/#install-an-editor","text":"In this section, you'll learn how to set up a code editor for Flutter development. Popular choices include VS Code and Android Studio. I will be using Android Studio in class and if like to follow along, I suggest the same IDE.","title":"Install an editor"},{"location":"0.1_getting_started/#run-flutter-doctor","text":"You should get something like this after you install everything. Output will look different based if you are on Windows or Linux, but you should have atleast one simulator working (andoroid or iOS) and also Chrome should work","title":"Run flutter doctor"},{"location":"0.1_getting_started/#test-drive","text":"This part helps you get hands-on experience by walking you through creating, running, and modifying a simple Flutter app.","title":"Test Drive"},{"location":"0.1_getting_started/#create-the-app","text":"Here, you'll create a new Flutter project using the command line or your chosen editor's interface.","title":"Create the app"},{"location":"0.1_getting_started/#run-the-app","text":"This step shows you how to run your Flutter app on a physical device or an emulator.","title":"Run the app"},{"location":"0.1_getting_started/#hot-reload","text":"Learn about Flutter's hot reload feature, which allows you to see changes instantly without rebuilding the entire app.","title":"Hot reload"},{"location":"0.1_getting_started/#run-on-multiple-platforms","text":"Run your app in a variety of platforms such as: iOS simulator Android simulator Windows MacOS Linux Chrome/Edge You can also try running on a physical device","title":"Run on multiple platforms"},{"location":"0.2_hello_world/","text":"Hello, World! 1. Create a new empty project called hello world Use flutter create --empty hello_world to create a new empty project. 2. Open project in an IDE Open the main.dart file inside the lib directory. This is the starting point of any Flutter app. You should see the following code. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } } This Flutter app creates a Material Design application with a simple layout ( Scaffold ) that has a centered text widget displaying \"Hello World!\". Let's break down each part of the code: Import Statement import 'package:flutter/material.dart' ; This line imports the Material Design package, which is a visual design language that is standard on mobile and the web. Flutter offers a rich set of pre-designed widgets that follow Material Design guidelines. Main Function void main () { runApp ( const MainApp ()); } void main() is the entry point of the Flutter app. When the app launches, this function is the first to be executed. runApp() is a Flutter function that takes a widget and makes it the root of the widget tree. In this case, MainApp() is the root widget. Stateless Widget class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { // ... } } class MainApp extends StatelessWidget : Here, we define a new widget called MainApp that inherits from StatelessWidget . A StatelessWidget is a widget that describes part of the user interface which can depend on the configuration but does not change over time. You will learn more about State in the upcoming lectures. const MainApp({super.key}); : This is the constructor for the MainApp widget. It allows for a key to be passed to the widget, which is useful for identifying widgets in the widget tree. @override : This indicates that we're overriding a method ( build method) from the parent class ( StatelessWidget ). Build Method Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } Widget build(BuildContext context) : This method returns a widget tree that Flutter uses to build the UI. It's a required override when you extend StatelessWidget or StatefulWidget . MaterialApp : This is the root widget for Material Design apps. It provides a number of useful features like navigation, theming, and so on. Scaffold : This is a basic layout structure where you can place other widgets. It can have elements like an AppBar , a Drawer , a BottomNavigationBar , etc. Center : This widget centers its child within itself. Text('Hello World!') : This is a simple text widget that displays \"Hello World!\". Update analysis_options.yaml Update the Analysis Options file so that the flutter linting is less aggressive Update main.dart Change font size child: Text ( 'Hello World!' , style: TextStyle ( fontSize: 48 ), ), By adding the style attribute, you can change the fontSize among many other things. Add an appBar to the Scaffold Add the appBar attribute to the Scaffold which creates a bar at the top of the screen. See more home: Scaffold ( appBar: AppBar ( title: Text ( 'Hello, World!' ), ), body: ... ) Change colours Adding lines 14 and 16 will change the colours of your app. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return MaterialApp ( home: Scaffold ( backgroundColor: Colors . amberAccent , appBar: AppBar ( backgroundColor: Colors . deepOrange , title: Text ( 'Hello, World!' ), ), body: Center ( child: Text ( 'Welcome to \\n COMP4768' , style: TextStyle ( fontSize: 48 ), ), ), ), ); } }","title":"0.2 Hello World"},{"location":"0.2_hello_world/#hello-world","text":"","title":"Hello, World!"},{"location":"0.2_hello_world/#1-create-a-new-empty-project-called-hello-world","text":"Use flutter create --empty hello_world to create a new empty project.","title":"1. Create a new empty project called hello world"},{"location":"0.2_hello_world/#2-open-project-in-an-ide","text":"Open the main.dart file inside the lib directory. This is the starting point of any Flutter app. You should see the following code. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } } This Flutter app creates a Material Design application with a simple layout ( Scaffold ) that has a centered text widget displaying \"Hello World!\". Let's break down each part of the code:","title":"2. Open project in an IDE"},{"location":"0.2_hello_world/#import-statement","text":"import 'package:flutter/material.dart' ; This line imports the Material Design package, which is a visual design language that is standard on mobile and the web. Flutter offers a rich set of pre-designed widgets that follow Material Design guidelines.","title":"Import Statement"},{"location":"0.2_hello_world/#main-function","text":"void main () { runApp ( const MainApp ()); } void main() is the entry point of the Flutter app. When the app launches, this function is the first to be executed. runApp() is a Flutter function that takes a widget and makes it the root of the widget tree. In this case, MainApp() is the root widget.","title":"Main Function"},{"location":"0.2_hello_world/#stateless-widget","text":"class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { // ... } } class MainApp extends StatelessWidget : Here, we define a new widget called MainApp that inherits from StatelessWidget . A StatelessWidget is a widget that describes part of the user interface which can depend on the configuration but does not change over time. You will learn more about State in the upcoming lectures. const MainApp({super.key}); : This is the constructor for the MainApp widget. It allows for a key to be passed to the widget, which is useful for identifying widgets in the widget tree. @override : This indicates that we're overriding a method ( build method) from the parent class ( StatelessWidget ).","title":"Stateless Widget"},{"location":"0.2_hello_world/#build-method","text":"Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } Widget build(BuildContext context) : This method returns a widget tree that Flutter uses to build the UI. It's a required override when you extend StatelessWidget or StatefulWidget . MaterialApp : This is the root widget for Material Design apps. It provides a number of useful features like navigation, theming, and so on. Scaffold : This is a basic layout structure where you can place other widgets. It can have elements like an AppBar , a Drawer , a BottomNavigationBar , etc. Center : This widget centers its child within itself. Text('Hello World!') : This is a simple text widget that displays \"Hello World!\".","title":"Build Method"},{"location":"0.2_hello_world/#update-analysis_optionsyaml","text":"Update the Analysis Options file so that the flutter linting is less aggressive","title":"Update analysis_options.yaml"},{"location":"0.2_hello_world/#update-maindart","text":"","title":"Update main.dart"},{"location":"0.2_hello_world/#change-font-size","text":"child: Text ( 'Hello World!' , style: TextStyle ( fontSize: 48 ), ), By adding the style attribute, you can change the fontSize among many other things.","title":"Change font size"},{"location":"0.2_hello_world/#add-an-appbar-to-the-scaffold","text":"Add the appBar attribute to the Scaffold which creates a bar at the top of the screen. See more home: Scaffold ( appBar: AppBar ( title: Text ( 'Hello, World!' ), ), body: ... )","title":"Add an appBar to the Scaffold"},{"location":"0.2_hello_world/#change-colours","text":"Adding lines 14 and 16 will change the colours of your app. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return MaterialApp ( home: Scaffold ( backgroundColor: Colors . amberAccent , appBar: AppBar ( backgroundColor: Colors . deepOrange , title: Text ( 'Hello, World!' ), ), body: Center ( child: Text ( 'Welcome to \\n COMP4768' , style: TextStyle ( fontSize: 48 ), ), ), ), ); } }","title":"Change colours"},{"location":"0.3_area_calc_app/","text":"Area Calculation App In this tutorial, you'll create an app to calculate area, gaining hands-on experience with key Flutter widgets, including: ElevatedButton TextField Column StatefulWidget StatelessWidget Here are some previews of the completed app: Ready to Begin? Step 1: Kickoff Launch a new Flutter project using Android Studio. For step-by-step guidance, you can refer to this official Flutter tutorial . Make sure that under Project Type, you select \"Empty Project\". See pic below: Go to the main.dart file in the lib folder. Your code should resemble the following. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } } The code creates a basic Flutter app that displays \"Hello World!\" on the screen. It starts by importing Flutter's Material Design library. The MainApp class defines the app's layout, which includes a centered text widget inside a scaffold. When you run the app, it launches this layout. Step 2: Setting Up HomeScreen In this phase, we'll construct a new StatefulWidget named HomePage , which will serve as the main screen for our application. First, generate a new file named HomePage.dart within the lib directory. Import the material.dart library and utilize the stful shortcut to create a standard stateful widget. Your HomePage.dart file should resemble the following code: import 'package:flutter/material.dart' ; class HomePage extends StatefulWidget { const HomePage ({ super . key }); @override State < HomePage > createState () => _HomePageState (); } class _HomePageState extends State < HomePage > { @override Widget build ( BuildContext context ) { return const Placeholder (); } } The code sets up a basic Flutter screen called HomePage . It's a stateful widget, meaning it can change over time. The HomePage class defines the structure, while _HomePageState handles what appears on the screen. Right now, it just shows a placeholder, indicating where future content will go. Return to the main.dart file and import the HomePage.dart file. Replace the existing child widget with the HomeScreen widget. After making these changes, run the app to confirm that main.dart now displays the content from HomePage.dart . ... import 'HomePage.dart' ; ... body: Center ( child: HomePage (), ), ...","title":"Area Calculation App"},{"location":"0.3_area_calc_app/#area-calculation-app","text":"In this tutorial, you'll create an app to calculate area, gaining hands-on experience with key Flutter widgets, including: ElevatedButton TextField Column StatefulWidget StatelessWidget Here are some previews of the completed app: Ready to Begin?","title":"Area Calculation App"},{"location":"0.3_area_calc_app/#step-1-kickoff","text":"Launch a new Flutter project using Android Studio. For step-by-step guidance, you can refer to this official Flutter tutorial . Make sure that under Project Type, you select \"Empty Project\". See pic below: Go to the main.dart file in the lib folder. Your code should resemble the following. import 'package:flutter/material.dart' ; void main () { runApp ( const MainApp ()); } class MainApp extends StatelessWidget { const MainApp ({ super . key }); @override Widget build ( BuildContext context ) { return const MaterialApp ( home: Scaffold ( body: Center ( child: Text ( 'Hello World!' ), ), ), ); } } The code creates a basic Flutter app that displays \"Hello World!\" on the screen. It starts by importing Flutter's Material Design library. The MainApp class defines the app's layout, which includes a centered text widget inside a scaffold. When you run the app, it launches this layout.","title":"Step 1: Kickoff"},{"location":"0.3_area_calc_app/#step-2-setting-up-homescreen","text":"In this phase, we'll construct a new StatefulWidget named HomePage , which will serve as the main screen for our application. First, generate a new file named HomePage.dart within the lib directory. Import the material.dart library and utilize the stful shortcut to create a standard stateful widget. Your HomePage.dart file should resemble the following code: import 'package:flutter/material.dart' ; class HomePage extends StatefulWidget { const HomePage ({ super . key }); @override State < HomePage > createState () => _HomePageState (); } class _HomePageState extends State < HomePage > { @override Widget build ( BuildContext context ) { return const Placeholder (); } } The code sets up a basic Flutter screen called HomePage . It's a stateful widget, meaning it can change over time. The HomePage class defines the structure, while _HomePageState handles what appears on the screen. Right now, it just shows a placeholder, indicating where future content will go. Return to the main.dart file and import the HomePage.dart file. Replace the existing child widget with the HomeScreen widget. After making these changes, run the app to confirm that main.dart now displays the content from HomePage.dart . ... import 'HomePage.dart' ; ... body: Center ( child: HomePage (), ), ...","title":"Step 2: Setting Up HomeScreen"},{"location":"1.0_basic_dart/","text":"Dart Fundamentals Basic Math import 'dart:math' ; void main () { print ( 2 + 2 ); print ( 8 ); print ( 9 ); print ( 2 ); print ( 1 ); print ( 0 ); print ( pow ( 2 , 5 )); } Adding Comments Single-line comments A single-line comment begins with // . Everything between // and the end of line is ignored by the Dart compiler. void main () { // TODO: refactor into an AbstractLlamaGreetingFactory? print ( 'Welcome to my Llama farm!' ); } Multi-line comments A multi-line comment begins with /* and ends with */ . Everything between /* and */ is ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). Multi-line comments can nest. void main () { /* * This is a lot of work. Consider raising chickens. Llama larry = Llama(); larry.feed(); larry.exercise(); larry.clean(); */ } Documentation comments Documentation comments are multi-line or single-line comments that begin with /// or /** . Using /// on consecutive lines has the same effect as a multi-line doc comment. Inside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level variables, functions, and parameters. The names in brackets are resolved in the lexical scope of the documented program element. Here is an example of documentation comments with references to other classes and arguments: /// A domesticated South American camelid (Lama glama). /// /// Andean cultures have used llamas as meat and pack /// animals since pre-Hispanic times. /// /// Just like any other animal, llamas need to eat, /// so don't forget to [feed] them some [Food]. class Llama { String ? name ; /// Feeds your llama [food]. /// /// The typical llama eats one bale of hay per week. void feed ( Food food ) { // ... } /// Exercises your llama with an [activity] for /// [timeLimit] minutes. void exercise ( Activity activity , int timeLimit ) { // ... } } Variables Here\u2019s an example of creating a variable and initializing it: var name = 'Bob' ; Variables store references. The variable called name contains a reference to a String object with a value of \u201cBob\u201d. The type of the name variable is inferred to be String , but you can change that type by specifying it. If an object isn't restricted to a single type, specify the Object type (or dynamic if necessary). Object name = 'Bob' ; Another option is to explicitly declare the type that would be inferred: String name = 'Bob' ; Numbers Dart numbers come in two flavors: [ int ][] : Integer values no larger than 64 bits, [depending on the platform][dart-numbers]. On native platforms, values can be from -2 63 to 2 63 - 1. On the web, integer values are represented as JavaScript numbers (64-bit floating-point values with no fractional part) and can be from -2 53 to 2 53 - 1. [ double ][] : 64-bit (double-precision) floating-point numbers, as specified by the IEEE 754 standard. Both int and double are subtypes of [ num ][]. The num type includes basic operators such as +, -, /, and *, and is also where you\u2019ll find abs() , ceil() , and floor() , among other methods. (Bitwise operators, such as >>, are defined in the int class.) If num and its subtypes don\u2019t have what you\u2019re looking for, the [dart:math][] library might. Integers are numbers without a decimal point. Here are some examples of defining integer literals: var x = 1 ; var hex = 0xDEADBEEF ; If a number includes a decimal, it is a double. Here are some examples of defining double literals: var y = 1.1 ; var exponents = 1.42e5 ; You can also declare a variable as a num. If you do this, the variable can have both integer and double values. num x = 1 ; // x can have both int and double values x += 2.5 ; Integer literals are automatically converted to doubles when necessary: double z = 1 ; // Equivalent to double z = 1.0. Here\u2019s how you turn a string into a number, or vice versa: // String -> int var one = int . parse ( '1' ); assert ( one == 1 ); // String -> double var onePointOne = double . parse ( '1.1' ); assert ( onePointOne == 1.1 ); // int -> String String oneAsString = 1. toString (); assert ( oneAsString == '1' ); // double -> String String piAsString = 3.14159 . toStringAsFixed ( 2 ); assert ( piAsString == '3.14' ); The int type specifies the traditional bitwise shift ( << , >> , >>> ), complement ( ~ ), AND ( & ), OR ( | ), and XOR ( ^ ) operators, which are useful for manipulating and masking flags in bit fields. For example: assert (( 3 << 1 ) == 6 ); // 0011 << 1 == 0110 assert (( 3 | 4 ) == 7 ); // 0011 | 0100 == 0111 assert (( 3 & 4 ) == 0 ); // 0011 & 0100 == 0000 For more examples, see the [bitwise and shift operator][] section. Literal numbers are compile-time constants. Many arithmetic expressions are also compile-time constants, as long as their operands are compile-time constants that evaluate to numbers. const msPerSecond = 1000 ; const secondsUntilRetry = 5 ; const msUntilRetry = secondsUntilRetry * msPerSecond ; For more information, see [Numbers in Dart][dart-numbers]. Variables What is a Variable? Think of a variable as a name tag for a piece of information. In Dart, you can create a variable like this: var name = 'Bob' ; Here, name is the variable, and it's holding the string 'Bob' . Types of Variables Dart can figure out the type of data you're storing, but you can also tell Dart the type: String name = 'Bob' ; Or even: Object name = 'Bob' ; Note : It's generally better to let Dart figure out the type of variable you're using, especially for local variables. Null Safety Dart has a feature called \"null safety\" to prevent errors when a variable doesn't have a value. How Null Safety Works Nullable and Non-Nullable Types : You can specify if a variable can be null : dart String? name; // Can be null or a string String name; // Cannot be null Initialization : You must give a value to non-nullable variables before using them. Null Checks : Dart prevents you from using variables that could be null in a way that would cause errors. Late Variables Sometimes you know you'll give a variable a value later on, but Dart doesn't know that. Use late to tell Dart the value will be there later: late String name ; Warning : If you don't give late variables a value before using them, your program will crash. Default Values If you don't give a variable a value, and it's nullable, it will be null : int ? lineCount ; Final and Const Variables final : Use this when you know a variable's value won't change after it's set. dart final name = 'Bob'; const : Use this for variables that you know will never change and are set at the start of the program. dart const pi = 3.14159; Note : final and const variables can't be changed once they're set. Also, const variables are set at compile-time, meaning the value needs to be known as the program is being created. Strings A Dart string ( String object) holds a sequence of UTF-16 code units. You can use either single or double quotes to create a string: var s1 = 'Single quotes work well for string literals.' ; var s2 = \"Double quotes work just as well.\" ; var s3 = 'It \\' s easy to escape the string delimiter.' ; var s4 = \"It's even easier to use the other delimiter.\" ; You can put the value of an expression inside a string by using ${ expression } . If the expression is an identifier, you can skip the {}. To get the string corresponding to an object, Dart calls the object\u2019s toString() method. var s = 'string interpolation' ; assert ( 'Dart has $ s , which is very handy.' == 'Dart has string interpolation, ' 'which is very handy.' ); assert ( 'That deserves all caps. ' ' ${ s . toUpperCase () } is very handy!' == 'That deserves all caps. ' 'STRING INTERPOLATION is very handy!' ); {{site.alert.note}} The == operator tests whether two objects are equivalent. Two strings are equivalent if they contain the same sequence of code units. {{site.alert.end}} You can concatenate strings using adjacent string literals or the + operator: var s1 = 'String ' 'concatenation' \" works even over line breaks.\" ; assert ( s1 == 'String concatenation works even over ' 'line breaks.' ); var s2 = 'The + operator ' + 'works, as well.' ; assert ( s2 == 'The + operator works, as well.' ); To create a multi-line string, use a triple quote with either single or double quotation marks: var s1 = ''' You can create multi-line strings like this one. ''' ; var s2 = \"\"\"This is also a multi-line string.\"\"\" ; You can create a \u201craw\u201d string by prefixing it with r : var s = r'In a raw string, not even \\n gets special treatment.' ; See Runes and grapheme clusters for details on how to express Unicode characters in a string. Literal strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value. // These work in a const string. const aConstNum = 0 ; const aConstBool = true ; const aConstString = 'a constant string' ; // These do NOT work in a const string. var aNum = 0 ; var aBool = true ; var aString = 'a string' ; const aConstList = [ 1 , 2 , 3 ]; const validConstString = ' $ aConstNum $ aConstBool $ aConstString ' ; // const invalidConstString = '$aNum $aBool $aString $aConstList'; For more information on using strings, check out Strings and regular expressions . Booleans To represent boolean values, Dart has a type named bool . Only two objects have type bool: the boolean literals true and false , which are both compile-time constants. // Check for an empty string. var fullName = '' ; assert ( fullName . isEmpty ); // Check for zero. var hitPoints = 0 ; assert ( hitPoints <= 0 ); // Check for null. var unicorn = null ; assert ( unicorn == null ); // Check for NaN. var iMeantToDoThis = 0 / 0 ; assert ( iMeantToDoThis . isNaN ); Numerical Values Text Strings True or False Values Lists Sets Maps Operators Const and Final Static and Dynamic","title":"Dart Fundamentals"},{"location":"1.0_basic_dart/#dart-fundamentals","text":"","title":"Dart Fundamentals"},{"location":"1.0_basic_dart/#basic-math","text":"import 'dart:math' ; void main () { print ( 2 + 2 ); print ( 8 ); print ( 9 ); print ( 2 ); print ( 1 ); print ( 0 ); print ( pow ( 2 , 5 )); }","title":"Basic Math"},{"location":"1.0_basic_dart/#adding-comments","text":"","title":"Adding Comments"},{"location":"1.0_basic_dart/#single-line-comments","text":"A single-line comment begins with // . Everything between // and the end of line is ignored by the Dart compiler. void main () { // TODO: refactor into an AbstractLlamaGreetingFactory? print ( 'Welcome to my Llama farm!' ); }","title":"Single-line comments"},{"location":"1.0_basic_dart/#multi-line-comments","text":"A multi-line comment begins with /* and ends with */ . Everything between /* and */ is ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). Multi-line comments can nest. void main () { /* * This is a lot of work. Consider raising chickens. Llama larry = Llama(); larry.feed(); larry.exercise(); larry.clean(); */ }","title":"Multi-line comments"},{"location":"1.0_basic_dart/#documentation-comments","text":"Documentation comments are multi-line or single-line comments that begin with /// or /** . Using /// on consecutive lines has the same effect as a multi-line doc comment. Inside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level variables, functions, and parameters. The names in brackets are resolved in the lexical scope of the documented program element. Here is an example of documentation comments with references to other classes and arguments: /// A domesticated South American camelid (Lama glama). /// /// Andean cultures have used llamas as meat and pack /// animals since pre-Hispanic times. /// /// Just like any other animal, llamas need to eat, /// so don't forget to [feed] them some [Food]. class Llama { String ? name ; /// Feeds your llama [food]. /// /// The typical llama eats one bale of hay per week. void feed ( Food food ) { // ... } /// Exercises your llama with an [activity] for /// [timeLimit] minutes. void exercise ( Activity activity , int timeLimit ) { // ... } }","title":"Documentation comments"},{"location":"1.0_basic_dart/#variables","text":"Here\u2019s an example of creating a variable and initializing it: var name = 'Bob' ; Variables store references. The variable called name contains a reference to a String object with a value of \u201cBob\u201d. The type of the name variable is inferred to be String , but you can change that type by specifying it. If an object isn't restricted to a single type, specify the Object type (or dynamic if necessary). Object name = 'Bob' ; Another option is to explicitly declare the type that would be inferred: String name = 'Bob' ;","title":"Variables"},{"location":"1.0_basic_dart/#numbers","text":"Dart numbers come in two flavors: [ int ][] : Integer values no larger than 64 bits, [depending on the platform][dart-numbers]. On native platforms, values can be from -2 63 to 2 63 - 1. On the web, integer values are represented as JavaScript numbers (64-bit floating-point values with no fractional part) and can be from -2 53 to 2 53 - 1. [ double ][] : 64-bit (double-precision) floating-point numbers, as specified by the IEEE 754 standard. Both int and double are subtypes of [ num ][]. The num type includes basic operators such as +, -, /, and *, and is also where you\u2019ll find abs() , ceil() , and floor() , among other methods. (Bitwise operators, such as >>, are defined in the int class.) If num and its subtypes don\u2019t have what you\u2019re looking for, the [dart:math][] library might. Integers are numbers without a decimal point. Here are some examples of defining integer literals: var x = 1 ; var hex = 0xDEADBEEF ; If a number includes a decimal, it is a double. Here are some examples of defining double literals: var y = 1.1 ; var exponents = 1.42e5 ; You can also declare a variable as a num. If you do this, the variable can have both integer and double values. num x = 1 ; // x can have both int and double values x += 2.5 ; Integer literals are automatically converted to doubles when necessary: double z = 1 ; // Equivalent to double z = 1.0. Here\u2019s how you turn a string into a number, or vice versa: // String -> int var one = int . parse ( '1' ); assert ( one == 1 ); // String -> double var onePointOne = double . parse ( '1.1' ); assert ( onePointOne == 1.1 ); // int -> String String oneAsString = 1. toString (); assert ( oneAsString == '1' ); // double -> String String piAsString = 3.14159 . toStringAsFixed ( 2 ); assert ( piAsString == '3.14' ); The int type specifies the traditional bitwise shift ( << , >> , >>> ), complement ( ~ ), AND ( & ), OR ( | ), and XOR ( ^ ) operators, which are useful for manipulating and masking flags in bit fields. For example: assert (( 3 << 1 ) == 6 ); // 0011 << 1 == 0110 assert (( 3 | 4 ) == 7 ); // 0011 | 0100 == 0111 assert (( 3 & 4 ) == 0 ); // 0011 & 0100 == 0000 For more examples, see the [bitwise and shift operator][] section. Literal numbers are compile-time constants. Many arithmetic expressions are also compile-time constants, as long as their operands are compile-time constants that evaluate to numbers. const msPerSecond = 1000 ; const secondsUntilRetry = 5 ; const msUntilRetry = secondsUntilRetry * msPerSecond ; For more information, see [Numbers in Dart][dart-numbers].","title":"Numbers"},{"location":"1.0_basic_dart/#variables_1","text":"","title":"Variables"},{"location":"1.0_basic_dart/#what-is-a-variable","text":"Think of a variable as a name tag for a piece of information. In Dart, you can create a variable like this: var name = 'Bob' ; Here, name is the variable, and it's holding the string 'Bob' .","title":"What is a Variable?"},{"location":"1.0_basic_dart/#types-of-variables","text":"Dart can figure out the type of data you're storing, but you can also tell Dart the type: String name = 'Bob' ; Or even: Object name = 'Bob' ; Note : It's generally better to let Dart figure out the type of variable you're using, especially for local variables.","title":"Types of Variables"},{"location":"1.0_basic_dart/#null-safety","text":"Dart has a feature called \"null safety\" to prevent errors when a variable doesn't have a value.","title":"Null Safety"},{"location":"1.0_basic_dart/#how-null-safety-works","text":"Nullable and Non-Nullable Types : You can specify if a variable can be null : dart String? name; // Can be null or a string String name; // Cannot be null Initialization : You must give a value to non-nullable variables before using them. Null Checks : Dart prevents you from using variables that could be null in a way that would cause errors.","title":"How Null Safety Works"},{"location":"1.0_basic_dart/#late-variables","text":"Sometimes you know you'll give a variable a value later on, but Dart doesn't know that. Use late to tell Dart the value will be there later: late String name ; Warning : If you don't give late variables a value before using them, your program will crash.","title":"Late Variables"},{"location":"1.0_basic_dart/#default-values","text":"If you don't give a variable a value, and it's nullable, it will be null : int ? lineCount ;","title":"Default Values"},{"location":"1.0_basic_dart/#final-and-const-variables","text":"final : Use this when you know a variable's value won't change after it's set. dart final name = 'Bob'; const : Use this for variables that you know will never change and are set at the start of the program. dart const pi = 3.14159; Note : final and const variables can't be changed once they're set. Also, const variables are set at compile-time, meaning the value needs to be known as the program is being created.","title":"Final and Const Variables"},{"location":"1.0_basic_dart/#strings","text":"A Dart string ( String object) holds a sequence of UTF-16 code units. You can use either single or double quotes to create a string: var s1 = 'Single quotes work well for string literals.' ; var s2 = \"Double quotes work just as well.\" ; var s3 = 'It \\' s easy to escape the string delimiter.' ; var s4 = \"It's even easier to use the other delimiter.\" ; You can put the value of an expression inside a string by using ${ expression } . If the expression is an identifier, you can skip the {}. To get the string corresponding to an object, Dart calls the object\u2019s toString() method. var s = 'string interpolation' ; assert ( 'Dart has $ s , which is very handy.' == 'Dart has string interpolation, ' 'which is very handy.' ); assert ( 'That deserves all caps. ' ' ${ s . toUpperCase () } is very handy!' == 'That deserves all caps. ' 'STRING INTERPOLATION is very handy!' ); {{site.alert.note}} The == operator tests whether two objects are equivalent. Two strings are equivalent if they contain the same sequence of code units. {{site.alert.end}} You can concatenate strings using adjacent string literals or the + operator: var s1 = 'String ' 'concatenation' \" works even over line breaks.\" ; assert ( s1 == 'String concatenation works even over ' 'line breaks.' ); var s2 = 'The + operator ' + 'works, as well.' ; assert ( s2 == 'The + operator works, as well.' ); To create a multi-line string, use a triple quote with either single or double quotation marks: var s1 = ''' You can create multi-line strings like this one. ''' ; var s2 = \"\"\"This is also a multi-line string.\"\"\" ; You can create a \u201craw\u201d string by prefixing it with r : var s = r'In a raw string, not even \\n gets special treatment.' ; See Runes and grapheme clusters for details on how to express Unicode characters in a string. Literal strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value. // These work in a const string. const aConstNum = 0 ; const aConstBool = true ; const aConstString = 'a constant string' ; // These do NOT work in a const string. var aNum = 0 ; var aBool = true ; var aString = 'a string' ; const aConstList = [ 1 , 2 , 3 ]; const validConstString = ' $ aConstNum $ aConstBool $ aConstString ' ; // const invalidConstString = '$aNum $aBool $aString $aConstList'; For more information on using strings, check out Strings and regular expressions .","title":"Strings"},{"location":"1.0_basic_dart/#booleans","text":"To represent boolean values, Dart has a type named bool . Only two objects have type bool: the boolean literals true and false , which are both compile-time constants. // Check for an empty string. var fullName = '' ; assert ( fullName . isEmpty ); // Check for zero. var hitPoints = 0 ; assert ( hitPoints <= 0 ); // Check for null. var unicorn = null ; assert ( unicorn == null ); // Check for NaN. var iMeantToDoThis = 0 / 0 ; assert ( iMeantToDoThis . isNaN );","title":"Booleans"},{"location":"1.0_basic_dart/#numerical-values","text":"","title":"Numerical Values"},{"location":"1.0_basic_dart/#text-strings","text":"","title":"Text Strings"},{"location":"1.0_basic_dart/#true-or-false-values","text":"","title":"True or False Values"},{"location":"1.0_basic_dart/#lists","text":"","title":"Lists"},{"location":"1.0_basic_dart/#sets","text":"","title":"Sets"},{"location":"1.0_basic_dart/#maps","text":"","title":"Maps"},{"location":"1.0_basic_dart/#operators","text":"","title":"Operators"},{"location":"1.0_basic_dart/#const-and-final","text":"","title":"Const and Final"},{"location":"1.0_basic_dart/#static-and-dynamic","text":"","title":"Static and Dynamic"},{"location":"1.0_first_app/","text":"How do I make my first Flutter app?","title":"How do I make my first Flutter app?"},{"location":"1.0_first_app/#how-do-i-make-my-first-flutter-app","text":"","title":"How do I make my first Flutter app?"},{"location":"1.0_syntax_basics/","text":"Syntax Basics Variables Here\u2019s an example of creating a variable and initializing it: var name = 'Bob' ; Variables store references. The variable called name contains a reference to a String object with a value of \u201cBob\u201d. The type of the name variable is inferred to be String , but you can change that type by specifying it. If an object isn't restricted to a single type, specify the Object type (or dynamic if necessary). Object name = 'Bob' ; Another option is to explicitly declare the type that would be inferred: String name = 'Bob' ; Null Safety in Dart What is Null Safety? Null safety is a feature in Dart that helps you avoid mistakes related to using null values. It catches these mistakes when you're writing the code, not when the code is running. Why is it Important? If you try to use a null value in a way that's not allowed, your program can crash. Dart's null safety helps you catch these issues early. Key Changes Introduced by Null Safety: Nullable and Non-Nullable Types : String? name : This means name can be either a string or null . String name : This means name can only be a string and never null . Initialization Requirement : You have to give a starting value to non-nullable variables. Nullable variables automatically start with null . Limited Operations on Nullable Types : If a variable can be null , you can't just use it like a regular variable. You have to check if it's null first. What Happens if You Don't Follow These Rules? The Dart compiler will show you an error message. You'll have to fix it before you can run your program. In short, null safety helps you write safer code by catching potential mistakes related to null values early on. Default Value in Dart Nullable Variables Start as Null If you declare a variable as nullable (like int? lineCount; ), it starts with a value of null . int ? lineCount ; assert ( lineCount == null ); What is assert() ? The assert() function checks if a condition is true. If it's not, the program stops running. This is mainly used during development to catch errors early. Non-Nullable Variables Need Initialization If a variable can't be null (like int lineCount; ), you must give it a starting value before using it. int lineCount = 0 ; Local Variables and Initialization You don't have to give a local variable its starting value right where you declare it. But you do have to give it a value before you use it. Dart checks this for you. int lineCount ; if ( weLikeToCount ) { lineCount = countLines (); } else { lineCount = 0 ; } print ( lineCount ); Lazy Initialization for Top-Level and Class Variables These variables only get their starting values the first time you use them. This is called \"lazy initialization.\" Dart requires you to be clear about whether a variable can be null and ensures you give a starting value to variables that can't be null . Late Variables What is the late Modifier? The late keyword in Dart is used for two main reasons: 1. To declare a variable that you will give a value to later, but you're sure it will have a value before you use it. 2. To delay the initialization of a variable until it's actually used. When to Use late ? Sometimes Dart can't figure out if a variable will have a value before it's used. This often happens with top-level variables and instance variables in classes. If you're sure the variable will have a value, you can use late to tell Dart it's okay. Example 1: Basic Usage late String description ; void main () { description = 'Feijoada!' ; print ( description ); } Here, description is declared as late , and it gets a value in the main() function before it's used. What Happens if You Forget to Initialize? If you declare a variable as late but never give it a value, you'll get a runtime error when you try to use it. Example 2: Lazy Initialization late String temperature = readThermometer (); In this example, readThermometer() is only called the first time temperature is used. This is useful when: - The initialization is expensive (takes a lot of time or resources). - The variable might not be needed at all. So, use late when you're sure a variable will be initialized before it's used, or when you want to delay its initialization. Final and Const What are Final and Const Variables? final : You can set its value only once. After that, it can't be changed. const : It's a value that's determined at the time the code is compiled, and it can't be changed later. How to Declare Them? final name = 'Bob'; or final String nickname = 'Bobby'; const bar = 1000000; or const double atm = 1.01325 * bar; Understanding the late Keyword in Dart The late keyword in Dart is a way to tell the Dart compiler that a variable will be initialized at some point in the future, but not right away. It's like telling Dart, \"Hey, I promise I'll give this variable a value before I use it, so don't worry about it for now.\" How Does It Work? Let's say you have a variable called name , and you know you'll give it a value later on. You can declare it like this: late String name ; Then, in your main() function or somewhere else, you can assign a value to it: void main () { name = \"John\" ; print ( name ); } Why Use late ? Avoid Null Errors : It helps you avoid null errors by allowing you to declare a non-nullable variable without initializing it right away. Lazy Initialization : It allows you to delay the initialization of a variable until you actually need it, which can save computational resources. What Happens If You Forget? If you declare a variable with late but forget to initialize it before using it, Dart will throw an error. So, you have to keep your promise! Examples Here's how you can use late in a class: class Person { late String name ; void greet () { print ( \"Hello $ name \" ); } } And in the main() function: void main () { Person person = Person (); person . name = \"John\" ; person . greet (); } What About late final ? If you want to assign a value to a variable only once and never change it, you can use late final : late final String name ; Operators Basic Math Operations in Dart Dart offers a variety of arithmetic operators to perform mathematical calculations. Here's a quick rundown: Addition ( + ) : Adds two numbers. Subtraction ( - ) : Subtracts one number from another. Negation ( -expr ) : Reverses the sign of a number. Multiplication ( * ) : Multiplies two numbers. Division ( / ) : Divides one number by another, returns a decimal. Integer Division ( ~/ ) : Divides and rounds down to the nearest integer. Remainder ( % ) : Gives the remainder after division. assert ( 2 + 3 == 5 ); assert ( 2 - 3 == - 1 ); assert ( 2 * 3 == 6 ); assert ( 5 / 2 == 2.5 ); assert ( 5 ~/ 2 == 2 ); assert ( 5 % 2 == 1 ); Increment and Decrement Dart also supports increment ( ++ ) and decrement ( -- ) operators, both in prefix and postfix forms. int a = 0 ; int b = ++ a ; // a is incremented before assigning to b. assert ( a == b ); // 1 == 1 a = 0 ; b = a ++ ; // a is incremented after assigning to b. assert ( a != b ); // 1 != 0 Comparing Values You can compare values using equality and relational operators: Equal ( == ) : Checks if two values are equal. Not Equal ( != ) : Checks if two values are not equal. Greater Than ( > ), Less Than ( < ), Greater or Equal ( >= ), Less or Equal ( <= ) : Compares two values. assert ( 2 == 2 ); assert ( 2 != 3 ); assert ( 3 > 2 ); assert ( 2 < 3 ); Type Checking Dart provides operators for runtime type checking: as : Casts an object to a specific type. is : Checks if an object is of a specific type. is! : Checks if an object is not of a specific type. if ( employee is Person ) { employee . firstName = 'Bob' ; } Assignment Operators You can assign values using = and use ??= to assign a value only if the variable is null. a = value ; // Assigns value to a b ??= value ; // Assigns value to b only if b is null Logical Operations Dart supports logical operators to work with boolean values: Not ( ! ) : Inverts a boolean value. OR ( || ) : Returns true if at least one condition is true. AND ( && ) : Returns true only if all conditions are true. if ( ! done && ( col == 0 || col == 3 )) { // Do something } Comments Comments in Dart Dart allows you to add comments to your code in three different ways: single-line comments, multi-line comments, and documentation comments. Single-Line Comments To write a single-line comment, use // . The Dart compiler will ignore everything from // to the end of the line. void main () { // This is a single-line comment print ( 'Hello, world!' ); } Multi-Line Comments For comments that span multiple lines, use /* to start and */ to end the comment. Everything between these markers is ignored by the Dart compiler. void main () { /* This is a multi-line comment. You can write as much as you want here. */ print ( 'Hello, world!' ); } Documentation Comments To write documentation comments, use /// for single-line or /** ... */ for multi-line comments. These comments are useful for generating API documentation. You can also include references to other parts of your code within square brackets [] . /// This is a Llama class. /// /// Don't forget to [feed] the llama. class Llama { /// This method [feeds] the llama. void feed () { // feeding code here } } In these documentation comments, text inside square brackets refers to other code elements, like methods or variables, and can be resolved to their definitions. Libraries and Imports Libraries and Imports in Dart Dart allows you to create modular and shareable code through the use of libraries and import directives. Libraries also serve as a unit of privacy, meaning identifiers starting with an underscore ( _ ) are only visible within that library. Using Libraries To use a library in Dart, you use the import directive. This specifies how a namespace from one library is used in the scope of another library. For example, to use the dart:html library in a Dart web app, you would import it like this: import 'dart:html' ; The only required argument for import is a URI that specifies the library. For built-in libraries, the URI uses the dart: scheme. For other libraries, you can use a file system path or the package: scheme. import 'package:test/test.dart' ; Specifying a Library Prefix If you have two libraries with conflicting identifiers, you can specify a prefix for one or both of them. For example: import 'package:lib1/lib1.dart' ; import 'package:lib2/lib2.dart' as lib2 ; Element element1 = Element (); // Uses Element from lib1 lib2 . Element element2 = lib2 . Element (); // Uses Element from lib2 Importing Only Part of a Library You can selectively import parts of a library using show or hide keywords. // Import only foo. import 'package:lib1/lib1.dart' show foo ; // Import all names EXCEPT foo. import 'package:lib2/lib2.dart' hide foo ; Lazily Loading a Library Deferred loading, also known as lazy loading, allows you to load a library on demand. This is useful for reducing initial startup time or for A/B testing. To lazily load a library, you must first import it using deferred as . import 'package:greetings/hello.dart' deferred as hello ; Then, you can load the library when needed using loadLibrary() . Future < void > greet () async { await hello . loadLibrary (); hello . printGreeting (); }","title":"1.0 Syntax Basics"},{"location":"1.0_syntax_basics/#syntax-basics","text":"","title":"Syntax Basics"},{"location":"1.0_syntax_basics/#variables","text":"Here\u2019s an example of creating a variable and initializing it: var name = 'Bob' ; Variables store references. The variable called name contains a reference to a String object with a value of \u201cBob\u201d. The type of the name variable is inferred to be String , but you can change that type by specifying it. If an object isn't restricted to a single type, specify the Object type (or dynamic if necessary). Object name = 'Bob' ; Another option is to explicitly declare the type that would be inferred: String name = 'Bob' ;","title":"Variables"},{"location":"1.0_syntax_basics/#null-safety-in-dart","text":"","title":"Null Safety in Dart"},{"location":"1.0_syntax_basics/#what-is-null-safety","text":"Null safety is a feature in Dart that helps you avoid mistakes related to using null values. It catches these mistakes when you're writing the code, not when the code is running.","title":"What is Null Safety?"},{"location":"1.0_syntax_basics/#why-is-it-important","text":"If you try to use a null value in a way that's not allowed, your program can crash. Dart's null safety helps you catch these issues early.","title":"Why is it Important?"},{"location":"1.0_syntax_basics/#key-changes-introduced-by-null-safety","text":"Nullable and Non-Nullable Types : String? name : This means name can be either a string or null . String name : This means name can only be a string and never null . Initialization Requirement : You have to give a starting value to non-nullable variables. Nullable variables automatically start with null . Limited Operations on Nullable Types : If a variable can be null , you can't just use it like a regular variable. You have to check if it's null first.","title":"Key Changes Introduced by Null Safety:"},{"location":"1.0_syntax_basics/#what-happens-if-you-dont-follow-these-rules","text":"The Dart compiler will show you an error message. You'll have to fix it before you can run your program. In short, null safety helps you write safer code by catching potential mistakes related to null values early on.","title":"What Happens if You Don't Follow These Rules?"},{"location":"1.0_syntax_basics/#default-value-in-dart","text":"","title":"Default Value in Dart"},{"location":"1.0_syntax_basics/#nullable-variables-start-as-null","text":"If you declare a variable as nullable (like int? lineCount; ), it starts with a value of null . int ? lineCount ; assert ( lineCount == null );","title":"Nullable Variables Start as Null"},{"location":"1.0_syntax_basics/#what-is-assert","text":"The assert() function checks if a condition is true. If it's not, the program stops running. This is mainly used during development to catch errors early.","title":"What is assert()?"},{"location":"1.0_syntax_basics/#non-nullable-variables-need-initialization","text":"If a variable can't be null (like int lineCount; ), you must give it a starting value before using it. int lineCount = 0 ;","title":"Non-Nullable Variables Need Initialization"},{"location":"1.0_syntax_basics/#local-variables-and-initialization","text":"You don't have to give a local variable its starting value right where you declare it. But you do have to give it a value before you use it. Dart checks this for you. int lineCount ; if ( weLikeToCount ) { lineCount = countLines (); } else { lineCount = 0 ; } print ( lineCount );","title":"Local Variables and Initialization"},{"location":"1.0_syntax_basics/#lazy-initialization-for-top-level-and-class-variables","text":"These variables only get their starting values the first time you use them. This is called \"lazy initialization.\" Dart requires you to be clear about whether a variable can be null and ensures you give a starting value to variables that can't be null .","title":"Lazy Initialization for Top-Level and Class Variables"},{"location":"1.0_syntax_basics/#late-variables","text":"","title":"Late Variables"},{"location":"1.0_syntax_basics/#what-is-the-late-modifier","text":"The late keyword in Dart is used for two main reasons: 1. To declare a variable that you will give a value to later, but you're sure it will have a value before you use it. 2. To delay the initialization of a variable until it's actually used.","title":"What is the late Modifier?"},{"location":"1.0_syntax_basics/#when-to-use-late","text":"Sometimes Dart can't figure out if a variable will have a value before it's used. This often happens with top-level variables and instance variables in classes. If you're sure the variable will have a value, you can use late to tell Dart it's okay.","title":"When to Use late?"},{"location":"1.0_syntax_basics/#example-1-basic-usage","text":"late String description ; void main () { description = 'Feijoada!' ; print ( description ); } Here, description is declared as late , and it gets a value in the main() function before it's used.","title":"Example 1: Basic Usage"},{"location":"1.0_syntax_basics/#what-happens-if-you-forget-to-initialize","text":"If you declare a variable as late but never give it a value, you'll get a runtime error when you try to use it.","title":"What Happens if You Forget to Initialize?"},{"location":"1.0_syntax_basics/#example-2-lazy-initialization","text":"late String temperature = readThermometer (); In this example, readThermometer() is only called the first time temperature is used. This is useful when: - The initialization is expensive (takes a lot of time or resources). - The variable might not be needed at all. So, use late when you're sure a variable will be initialized before it's used, or when you want to delay its initialization.","title":"Example 2: Lazy Initialization"},{"location":"1.0_syntax_basics/#final-and-const","text":"","title":"Final and Const"},{"location":"1.0_syntax_basics/#what-are-final-and-const-variables","text":"final : You can set its value only once. After that, it can't be changed. const : It's a value that's determined at the time the code is compiled, and it can't be changed later.","title":"What are Final and Const Variables?"},{"location":"1.0_syntax_basics/#how-to-declare-them","text":"final name = 'Bob'; or final String nickname = 'Bobby'; const bar = 1000000; or const double atm = 1.01325 * bar;","title":"How to Declare Them?"},{"location":"1.0_syntax_basics/#understanding-the-late-keyword-in-dart","text":"The late keyword in Dart is a way to tell the Dart compiler that a variable will be initialized at some point in the future, but not right away. It's like telling Dart, \"Hey, I promise I'll give this variable a value before I use it, so don't worry about it for now.\"","title":"Understanding the late Keyword in Dart"},{"location":"1.0_syntax_basics/#how-does-it-work","text":"Let's say you have a variable called name , and you know you'll give it a value later on. You can declare it like this: late String name ; Then, in your main() function or somewhere else, you can assign a value to it: void main () { name = \"John\" ; print ( name ); }","title":"How Does It Work?"},{"location":"1.0_syntax_basics/#why-use-late","text":"Avoid Null Errors : It helps you avoid null errors by allowing you to declare a non-nullable variable without initializing it right away. Lazy Initialization : It allows you to delay the initialization of a variable until you actually need it, which can save computational resources.","title":"Why Use late?"},{"location":"1.0_syntax_basics/#what-happens-if-you-forget","text":"If you declare a variable with late but forget to initialize it before using it, Dart will throw an error. So, you have to keep your promise!","title":"What Happens If You Forget?"},{"location":"1.0_syntax_basics/#examples","text":"Here's how you can use late in a class: class Person { late String name ; void greet () { print ( \"Hello $ name \" ); } } And in the main() function: void main () { Person person = Person (); person . name = \"John\" ; person . greet (); }","title":"Examples"},{"location":"1.0_syntax_basics/#what-about-late-final","text":"If you want to assign a value to a variable only once and never change it, you can use late final : late final String name ;","title":"What About late final?"},{"location":"1.0_syntax_basics/#operators","text":"","title":"Operators"},{"location":"1.0_syntax_basics/#basic-math-operations-in-dart","text":"Dart offers a variety of arithmetic operators to perform mathematical calculations. Here's a quick rundown: Addition ( + ) : Adds two numbers. Subtraction ( - ) : Subtracts one number from another. Negation ( -expr ) : Reverses the sign of a number. Multiplication ( * ) : Multiplies two numbers. Division ( / ) : Divides one number by another, returns a decimal. Integer Division ( ~/ ) : Divides and rounds down to the nearest integer. Remainder ( % ) : Gives the remainder after division. assert ( 2 + 3 == 5 ); assert ( 2 - 3 == - 1 ); assert ( 2 * 3 == 6 ); assert ( 5 / 2 == 2.5 ); assert ( 5 ~/ 2 == 2 ); assert ( 5 % 2 == 1 );","title":"Basic Math Operations in Dart"},{"location":"1.0_syntax_basics/#increment-and-decrement","text":"Dart also supports increment ( ++ ) and decrement ( -- ) operators, both in prefix and postfix forms. int a = 0 ; int b = ++ a ; // a is incremented before assigning to b. assert ( a == b ); // 1 == 1 a = 0 ; b = a ++ ; // a is incremented after assigning to b. assert ( a != b ); // 1 != 0","title":"Increment and Decrement"},{"location":"1.0_syntax_basics/#comparing-values","text":"You can compare values using equality and relational operators: Equal ( == ) : Checks if two values are equal. Not Equal ( != ) : Checks if two values are not equal. Greater Than ( > ), Less Than ( < ), Greater or Equal ( >= ), Less or Equal ( <= ) : Compares two values. assert ( 2 == 2 ); assert ( 2 != 3 ); assert ( 3 > 2 ); assert ( 2 < 3 );","title":"Comparing Values"},{"location":"1.0_syntax_basics/#type-checking","text":"Dart provides operators for runtime type checking: as : Casts an object to a specific type. is : Checks if an object is of a specific type. is! : Checks if an object is not of a specific type. if ( employee is Person ) { employee . firstName = 'Bob' ; }","title":"Type Checking"},{"location":"1.0_syntax_basics/#assignment-operators","text":"You can assign values using = and use ??= to assign a value only if the variable is null. a = value ; // Assigns value to a b ??= value ; // Assigns value to b only if b is null","title":"Assignment Operators"},{"location":"1.0_syntax_basics/#logical-operations","text":"Dart supports logical operators to work with boolean values: Not ( ! ) : Inverts a boolean value. OR ( || ) : Returns true if at least one condition is true. AND ( && ) : Returns true only if all conditions are true. if ( ! done && ( col == 0 || col == 3 )) { // Do something }","title":"Logical Operations"},{"location":"1.0_syntax_basics/#comments","text":"","title":"Comments"},{"location":"1.0_syntax_basics/#comments-in-dart","text":"Dart allows you to add comments to your code in three different ways: single-line comments, multi-line comments, and documentation comments.","title":"Comments in Dart"},{"location":"1.0_syntax_basics/#single-line-comments","text":"To write a single-line comment, use // . The Dart compiler will ignore everything from // to the end of the line. void main () { // This is a single-line comment print ( 'Hello, world!' ); }","title":"Single-Line Comments"},{"location":"1.0_syntax_basics/#multi-line-comments","text":"For comments that span multiple lines, use /* to start and */ to end the comment. Everything between these markers is ignored by the Dart compiler. void main () { /* This is a multi-line comment. You can write as much as you want here. */ print ( 'Hello, world!' ); }","title":"Multi-Line Comments"},{"location":"1.0_syntax_basics/#documentation-comments","text":"To write documentation comments, use /// for single-line or /** ... */ for multi-line comments. These comments are useful for generating API documentation. You can also include references to other parts of your code within square brackets [] . /// This is a Llama class. /// /// Don't forget to [feed] the llama. class Llama { /// This method [feeds] the llama. void feed () { // feeding code here } } In these documentation comments, text inside square brackets refers to other code elements, like methods or variables, and can be resolved to their definitions.","title":"Documentation Comments"},{"location":"1.0_syntax_basics/#libraries-and-imports","text":"","title":"Libraries and Imports"},{"location":"1.0_syntax_basics/#libraries-and-imports-in-dart","text":"Dart allows you to create modular and shareable code through the use of libraries and import directives. Libraries also serve as a unit of privacy, meaning identifiers starting with an underscore ( _ ) are only visible within that library.","title":"Libraries and Imports in Dart"},{"location":"1.0_syntax_basics/#using-libraries","text":"To use a library in Dart, you use the import directive. This specifies how a namespace from one library is used in the scope of another library. For example, to use the dart:html library in a Dart web app, you would import it like this: import 'dart:html' ; The only required argument for import is a URI that specifies the library. For built-in libraries, the URI uses the dart: scheme. For other libraries, you can use a file system path or the package: scheme. import 'package:test/test.dart' ;","title":"Using Libraries"},{"location":"1.0_syntax_basics/#specifying-a-library-prefix","text":"If you have two libraries with conflicting identifiers, you can specify a prefix for one or both of them. For example: import 'package:lib1/lib1.dart' ; import 'package:lib2/lib2.dart' as lib2 ; Element element1 = Element (); // Uses Element from lib1 lib2 . Element element2 = lib2 . Element (); // Uses Element from lib2","title":"Specifying a Library Prefix"},{"location":"1.0_syntax_basics/#importing-only-part-of-a-library","text":"You can selectively import parts of a library using show or hide keywords. // Import only foo. import 'package:lib1/lib1.dart' show foo ; // Import all names EXCEPT foo. import 'package:lib2/lib2.dart' hide foo ;","title":"Importing Only Part of a Library"},{"location":"1.0_syntax_basics/#lazily-loading-a-library","text":"Deferred loading, also known as lazy loading, allows you to load a library on demand. This is useful for reducing initial startup time or for A/B testing. To lazily load a library, you must first import it using deferred as . import 'package:greetings/hello.dart' deferred as hello ; Then, you can load the library when needed using loadLibrary() . Future < void > greet () async { await hello . loadLibrary (); hello . printGreeting (); }","title":"Lazily Loading a Library"},{"location":"1.1_types/","text":"Types Built-in types Numbers (int, double) Types of Numbers In Dart, you have two main types of numbers: int : These are whole numbers. They can be as large as 64 bits, but the range varies depending on where your code runs. For example, in a web browser, the range is from -2^53 to 2^53 - 1. double : These are numbers with decimal points, and they follow a standard called IEEE 754. Both int and double come under a general type called num , which has basic math operations like addition (+), subtraction (-), and so on. Examples Integer (int): var x = 1 ; var hex = 0xDEADBEEF ; Decimal (double): var y = 1.1 ; var exponents = 1.42e5 ; General number (num): num x = 1 ; x += 2.5 ; Converting Types From string to int or double: var one = int . parse ( '1' ); var onePointOne = double . parse ( '1.1' ); From int or double to string: String oneAsString = 1. toString (); String piAsString = 3.14159 . toStringAsFixed ( 2 ); Bitwise Operations You can also perform bitwise operations like shifting and masking with integers. For example: assert (( 3 << 1 ) == 6 ); assert (( 3 | 4 ) == 7 ); Constants Numbers can be constants, and you can perform calculations with them at compile-time. const msPerSecond = 1000 ; const msUntilRetry = secondsUntilRetry * msPerSecond ; That's the gist of working with numbers in Dart! For more, see this . Strings (String) What is a String? In Dart, a string is a sequence of characters. You can create a string using either single ( ' ' ) or double ( \" \" ) quotes. Examples Using single quotes: dart var s1 = 'Hello, world!'; Using double quotes: dart var s2 = \"Hello, again!\"; Escaping quotes: dart var s3 = 'It\\'s a sunny day!'; String Interpolation You can insert the value of a variable or expression into a string using ${expression} . If it's just a variable name, you can even skip the curly braces ( {} ). Example: dart var name = 'John'; print('Hello, ${name.toUpperCase()}'); // Output: Hello, JOHN Comparing Strings To check if two strings are the same, use the == operator. Joining Strings You can join two or more strings in several ways: By simply placing them next to each other. Using the + operator. Multi-Line Strings To write a string that spans multiple lines, use triple quotes ( ''' ''' or \"\"\" \"\"\" ). Example: dart var poem = ''' Roses are red, Violets are blue. '''; Raw Strings If you don't want special characters like \\n to be treated specially, use a raw string by adding r before the string. Example: dart var rawString = r'This is a \\n raw string.'; Constants Strings can be constants if they don't contain any variables that change at runtime. Example: dart const aConstString = 'This is a constant string'; And that's a quick rundown of how to work with strings in Dart! Booleans (bool) In Dart, the bool type can only be true or false , and these are fixed constants. Dart is strict about types, so you can't use non-boolean values in if or assert statements. // Check for an empty string. var fullName = '' ; assert ( fullName . isEmpty ); // Check for zero. var hitPoints = 0 ; assert ( hitPoints <= 0 ); // Check for null. var unicorn = null ; assert ( unicorn == null ); // Check for NaN. var iMeantToDoThis = 0 / 0 ; assert ( iMeantToDoThis . isNaN ); Records ((value1, value2)) What are Records? Records are a special kind of data structure that lets you group different types of data together into one object. They are: Anonymous : Don't have a name. Immutable : Can't be changed once created. Fixed-Size : Can't add or remove items. Typed : Each item has a specific type. You can use records just like any other data type: store them in variables, use them in functions, or even put them in lists and maps. How to Use Records Creating a Record : Use parentheses to group data together. ( int , int ) rec = ( 10 , 20 ); var record = ( 'first' , a: 2 , b: true , 'last' ); ({ int a , int b }) namedRecord = ( a: 10 , b: 20 ); Record type annotations are comma-delimited lists of types enclosed in parentheses. You can use record type annotations to define return types and parameter types. For example, the following (int, int) statements are record type annotations: ( int , int ) swap (( int , int ) record ) { var ( a , b ) = record ; return ( b , a ); } Named and Positional Fields : Records can have both named and positional fields. Named fields use curly braces. ({ int a , bool b }) record = ( a: 123 , b: true ); Type Matching : Records with different named fields are considered different types. ({ int a , int b }) recordAB = ( a: 1 , b: 2 ); ({ int x , int y }) recordXY = ( x: 3 , y: 4 ); // This will cause an error because they are different types. // recordAB = recordXY; Accessing Record Fields You can access the data in a record using built-in getters. Since records are immutable, you can't change the data once it's set. var record = ( 'first' , a: 2 , b: true , 'last' ); print ( record . $1 ); // Prints 'first' print ( record . a ); // Prints 2 print ( record . b ); // Prints true print ( record . $2 ); // Prints 'last' Record Types and Equality Records are identified by their shape, which is defined by the types, names, and order of their fields. Two records are equal if their shapes and the data inside them are the same. Returning Multiple Values Records are useful for functions that need to return more than one value. You can easily unpack these values into variables. ( String , int ) userInfo ( Map < String , dynamic > json ) { return ( json [ 'name' ] as String , json [ 'age' ] as int ); } var ( name , age ) = userInfo ( json ); Lists (List, also known as arrays) As demonstrated in the language tour, you can use literals to create and initialize lists . Alternatively, you can use one of the List constructors. The List class also provides several methods for adding and removing items. // Create an empty list of strings. var grains = < String > []; assert ( grains . isEmpty ); // Create a list using a list literal. var fruits = [ 'apples' , 'oranges' ]; // Add to a list. fruits . add ( 'kiwis' ); // Add multiple items to a list. fruits . addAll ([ 'grapes' , 'bananas' ]); // Get the list length. assert ( fruits . length == 5 ); // Remove a single item. var appleIndex = fruits . indexOf ( 'apples' ); fruits . removeAt ( appleIndex ); assert ( fruits . length == 4 ); // Remove all elements from a list. fruits . clear (); assert ( fruits . isEmpty ); // You can also create a List using one of the constructors. var vegetables = List . filled ( 99 , 'broccoli' ); assert ( vegetables . every (( v ) => v == 'broccoli' )); To find the index of an object in a list, use indexOf() : var fruits = [ 'apples' , 'oranges' ]; // Access a list item by index. assert ( fruits [ 0 ] == 'apples' ); // Find an item in a list. assert ( fruits . indexOf ( 'apples' ) == 0 ); To sort a list, use the sort() method. You can provide a sorting function that compares two objects: var fruits = [ 'bananas' , 'apples' , 'oranges' ]; // Sort a list. fruits . sort (( a , b ) => a . compareTo ( b )); assert ( fruits [ 0 ] == 'apples' ); Lists are parameterized types ( generics ), allowing you to specify the type of elements they should contain: // This list should contain only strings. var fruits = < String > []; fruits . add ( 'apples' ); var fruit = fruits [ 0 ]; assert ( fruit is String ); Note: In many cases, you don't need to explicitly specify generic types, as Dart will infer them for you. However, there are times when you should specify them, especially when Dart has nothing to infer from. Sets (Set) A set in Dart is an unordered collection of unique items. Sets do not support indexing. // Create an empty set of strings. var ingredients = < String > {}; // Add new items to it. ingredients . addAll ([ 'gold' , 'titanium' , 'xenon' ]); assert ( ingredients . length == 3 ); // Adding a duplicate item has no effect. ingredients . add ( 'gold' ); assert ( ingredients . length == 3 ); // Remove an item from a set. ingredients . remove ( 'gold' ); assert ( ingredients . length == 2 ); // You can also create sets using constructors. var atomicNumbers = Set . from ([ 79 , 22 , 54 ]); To check for the presence of one or more objects in a set, use contains() and containsAll() : var ingredients = Set < String > (); ingredients . addAll ([ 'gold' , 'titanium' , 'xenon' ]); // Check whether an item is in the set. assert ( ingredients . contains ( 'titanium' )); // Check whether all the items are in the set. assert ( ingredients . containsAll ([ 'titanium' , 'xenon' ])); Maps (Map) A map, commonly known as a dictionary or hash , is an unordered collection of key-value pairs. Maps associate a key to some value for easy retrieval. Unlike in JavaScript, Dart objects are not maps. You can declare a map using a terse literal syntax, or you can use a traditional constructor: // Maps often use strings as keys. var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; // Maps can be built from a constructor. var searchTerms = Map (); // Maps are parameterized types; you can specify what // types the key and value should be. var nobleGases = Map < int , String > (); You add, get, and set map items using the bracket syntax. Use remove() to remove a key and its value from a map. var nobleGases = { 54 : 'xenon' }; // Retrieve a value with a key. assert ( nobleGases [ 54 ] == 'xenon' ); // Check whether a map contains a key. assert ( nobleGases . containsKey ( 54 )); // Remove a key and its value. nobleGases . remove ( 54 ); assert ( ! nobleGases . containsKey ( 54 )); You can retrieve all the values or all the keys from a map: var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; // Get all the keys as an unordered collection // (an Iterable). var keys = hawaiianBeaches . keys ; assert ( keys . length == 3 ); assert ( Set . from ( keys ). contains ( 'Oahu' )); // Get all the values as an unordered collection // (an Iterable of Lists). var values = hawaiianBeaches . values ; assert ( values . length == 3 ); assert ( values . any (( v ) => v . contains ( 'Waikiki' ))); To check whether a map contains a key, use containsKey() . Because map values can be null, you cannot rely on simply getting the value for the key and checking for null to determine the existence of a key. var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; assert ( hawaiianBeaches . containsKey ( 'Oahu' )); assert ( ! hawaiianBeaches . containsKey ( 'Florida' )); Use the putIfAbsent() method when you want to assign a value to a key if and only if the key does not already exist in a map. You must provide a function that returns the value. var teamAssignments = < String , String > {}; teamAssignments . putIfAbsent ( 'Catcher' , () => pickToughestKid ()); assert ( teamAssignments [ 'Catcher' ] != null ); Refer to the [Map API reference][Map] for a full list of methods. Common collection methods List, Set, and Map share common functionality found in many collections. Some of this common functionality is defined by the Iterable class, which List and Set implement. {{site.alert.note}} Although Map doesn\u2019t implement Iterable, you can get Iterables from it using the Map keys and values properties. {{site.alert.end}} Use isEmpty or isNotEmpty to check whether a list, set, or map has items: var coffees = < String > []; var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; assert ( coffees . isEmpty ); assert ( teas . isNotEmpty ); To apply a function to each item in a list, set, or map, you can use forEach() : var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; teas . forEach (( tea ) => print ( 'I drink $ tea ' )); When you invoke forEach() on a map, your function must take two arguments (the key and value): hawaiianBeaches . forEach (( k , v ) { print ( 'I want to visit $ k and swim at $ v ' ); // I want to visit Oahu and swim at // [Waikiki, Kailua, Waimanalo], etc. }); Iterables provide the map() method, which gives you all the results in a single object: var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; var loudTeas = teas . map (( tea ) => tea . toUpperCase ()); loudTeas . forEach ( print ); {{site.alert.note}} The object returned by map() is an Iterable that\u2019s lazily evaluated : your function isn\u2019t called until you ask for an item from the returned object. {{site.alert.end}} To force your function to be called immediately on each item, use map().toList() or map().toSet() : var loudTeas = teas . map (( tea ) => tea . toUpperCase ()). toList (); Use Iterable\u2019s where() method to get all the items that match a condition. Use Iterable\u2019s any() and every() methods to check whether some or all items match a condition. {% comment %} PENDING: Change example as suggested by floitsch to have (maybe) cities instead of isDecaffeinated. var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; // Chamomile is not caffeinated. bool isDecaffeinated ( String teaName ) => teaName == 'chamomile' ; // Use where() to find only the items that return true // from the provided function. var decaffeinatedTeas = teas . where (( tea ) => isDecaffeinated ( tea )); // or teas.where(isDecaffeinated) // Use any() to check whether at least one item in the // collection satisfies a condition. assert ( teas . any ( isDecaffeinated )); // Use every() to check whether all the items in a // collection satisfy a condition. assert ( ! teas . every ( isDecaffeinated )); Runes (Runes; often replaced by the characters API) Runes: In Dart, runes are integers representing Unicode code points. They are used to handle characters that are not in the basic ASCII range. Dart has a Runes class for manipulating them. Symbols (Symbol) Symbols: In Dart, symbols are immutable, unique identifiers used mainly for reflection. Created using the # symbol, they allow you to access properties and methods dynamically. The value null (Null) The value null: In Dart, \"null\" indicates the absence of a value. It is the default value for variables that haven't been initialized and is used to represent the idea of \"nothing\" in the code.","title":"1.1 Types"},{"location":"1.1_types/#types","text":"","title":"Types"},{"location":"1.1_types/#built-in-types","text":"","title":"Built-in types"},{"location":"1.1_types/#numbers-int-double","text":"","title":"Numbers (int, double)"},{"location":"1.1_types/#types-of-numbers","text":"In Dart, you have two main types of numbers: int : These are whole numbers. They can be as large as 64 bits, but the range varies depending on where your code runs. For example, in a web browser, the range is from -2^53 to 2^53 - 1. double : These are numbers with decimal points, and they follow a standard called IEEE 754. Both int and double come under a general type called num , which has basic math operations like addition (+), subtraction (-), and so on.","title":"Types of Numbers"},{"location":"1.1_types/#examples","text":"Integer (int): var x = 1 ; var hex = 0xDEADBEEF ; Decimal (double): var y = 1.1 ; var exponents = 1.42e5 ; General number (num): num x = 1 ; x += 2.5 ;","title":"Examples"},{"location":"1.1_types/#converting-types","text":"From string to int or double: var one = int . parse ( '1' ); var onePointOne = double . parse ( '1.1' ); From int or double to string: String oneAsString = 1. toString (); String piAsString = 3.14159 . toStringAsFixed ( 2 );","title":"Converting Types"},{"location":"1.1_types/#bitwise-operations","text":"You can also perform bitwise operations like shifting and masking with integers. For example: assert (( 3 << 1 ) == 6 ); assert (( 3 | 4 ) == 7 );","title":"Bitwise Operations"},{"location":"1.1_types/#constants","text":"Numbers can be constants, and you can perform calculations with them at compile-time. const msPerSecond = 1000 ; const msUntilRetry = secondsUntilRetry * msPerSecond ; That's the gist of working with numbers in Dart! For more, see this .","title":"Constants"},{"location":"1.1_types/#strings-string","text":"","title":"Strings (String)"},{"location":"1.1_types/#what-is-a-string","text":"In Dart, a string is a sequence of characters. You can create a string using either single ( ' ' ) or double ( \" \" ) quotes.","title":"What is a String?"},{"location":"1.1_types/#examples_1","text":"Using single quotes: dart var s1 = 'Hello, world!'; Using double quotes: dart var s2 = \"Hello, again!\"; Escaping quotes: dart var s3 = 'It\\'s a sunny day!';","title":"Examples"},{"location":"1.1_types/#string-interpolation","text":"You can insert the value of a variable or expression into a string using ${expression} . If it's just a variable name, you can even skip the curly braces ( {} ). Example: dart var name = 'John'; print('Hello, ${name.toUpperCase()}'); // Output: Hello, JOHN","title":"String Interpolation"},{"location":"1.1_types/#comparing-strings","text":"To check if two strings are the same, use the == operator.","title":"Comparing Strings"},{"location":"1.1_types/#joining-strings","text":"You can join two or more strings in several ways: By simply placing them next to each other. Using the + operator.","title":"Joining Strings"},{"location":"1.1_types/#multi-line-strings","text":"To write a string that spans multiple lines, use triple quotes ( ''' ''' or \"\"\" \"\"\" ). Example: dart var poem = ''' Roses are red, Violets are blue. ''';","title":"Multi-Line Strings"},{"location":"1.1_types/#raw-strings","text":"If you don't want special characters like \\n to be treated specially, use a raw string by adding r before the string. Example: dart var rawString = r'This is a \\n raw string.';","title":"Raw Strings"},{"location":"1.1_types/#constants_1","text":"Strings can be constants if they don't contain any variables that change at runtime. Example: dart const aConstString = 'This is a constant string'; And that's a quick rundown of how to work with strings in Dart!","title":"Constants"},{"location":"1.1_types/#booleans-bool","text":"In Dart, the bool type can only be true or false , and these are fixed constants. Dart is strict about types, so you can't use non-boolean values in if or assert statements. // Check for an empty string. var fullName = '' ; assert ( fullName . isEmpty ); // Check for zero. var hitPoints = 0 ; assert ( hitPoints <= 0 ); // Check for null. var unicorn = null ; assert ( unicorn == null ); // Check for NaN. var iMeantToDoThis = 0 / 0 ; assert ( iMeantToDoThis . isNaN );","title":"Booleans (bool)"},{"location":"1.1_types/#records-value1-value2","text":"","title":"Records ((value1, value2))"},{"location":"1.1_types/#what-are-records","text":"Records are a special kind of data structure that lets you group different types of data together into one object. They are: Anonymous : Don't have a name. Immutable : Can't be changed once created. Fixed-Size : Can't add or remove items. Typed : Each item has a specific type. You can use records just like any other data type: store them in variables, use them in functions, or even put them in lists and maps.","title":"What are Records?"},{"location":"1.1_types/#how-to-use-records","text":"Creating a Record : Use parentheses to group data together. ( int , int ) rec = ( 10 , 20 ); var record = ( 'first' , a: 2 , b: true , 'last' ); ({ int a , int b }) namedRecord = ( a: 10 , b: 20 ); Record type annotations are comma-delimited lists of types enclosed in parentheses. You can use record type annotations to define return types and parameter types. For example, the following (int, int) statements are record type annotations: ( int , int ) swap (( int , int ) record ) { var ( a , b ) = record ; return ( b , a ); } Named and Positional Fields : Records can have both named and positional fields. Named fields use curly braces. ({ int a , bool b }) record = ( a: 123 , b: true ); Type Matching : Records with different named fields are considered different types. ({ int a , int b }) recordAB = ( a: 1 , b: 2 ); ({ int x , int y }) recordXY = ( x: 3 , y: 4 ); // This will cause an error because they are different types. // recordAB = recordXY;","title":"How to Use Records"},{"location":"1.1_types/#accessing-record-fields","text":"You can access the data in a record using built-in getters. Since records are immutable, you can't change the data once it's set. var record = ( 'first' , a: 2 , b: true , 'last' ); print ( record . $1 ); // Prints 'first' print ( record . a ); // Prints 2 print ( record . b ); // Prints true print ( record . $2 ); // Prints 'last'","title":"Accessing Record Fields"},{"location":"1.1_types/#record-types-and-equality","text":"Records are identified by their shape, which is defined by the types, names, and order of their fields. Two records are equal if their shapes and the data inside them are the same.","title":"Record Types and Equality"},{"location":"1.1_types/#returning-multiple-values","text":"Records are useful for functions that need to return more than one value. You can easily unpack these values into variables. ( String , int ) userInfo ( Map < String , dynamic > json ) { return ( json [ 'name' ] as String , json [ 'age' ] as int ); } var ( name , age ) = userInfo ( json );","title":"Returning Multiple Values"},{"location":"1.1_types/#lists-list-also-known-as-arrays","text":"As demonstrated in the language tour, you can use literals to create and initialize lists . Alternatively, you can use one of the List constructors. The List class also provides several methods for adding and removing items. // Create an empty list of strings. var grains = < String > []; assert ( grains . isEmpty ); // Create a list using a list literal. var fruits = [ 'apples' , 'oranges' ]; // Add to a list. fruits . add ( 'kiwis' ); // Add multiple items to a list. fruits . addAll ([ 'grapes' , 'bananas' ]); // Get the list length. assert ( fruits . length == 5 ); // Remove a single item. var appleIndex = fruits . indexOf ( 'apples' ); fruits . removeAt ( appleIndex ); assert ( fruits . length == 4 ); // Remove all elements from a list. fruits . clear (); assert ( fruits . isEmpty ); // You can also create a List using one of the constructors. var vegetables = List . filled ( 99 , 'broccoli' ); assert ( vegetables . every (( v ) => v == 'broccoli' )); To find the index of an object in a list, use indexOf() : var fruits = [ 'apples' , 'oranges' ]; // Access a list item by index. assert ( fruits [ 0 ] == 'apples' ); // Find an item in a list. assert ( fruits . indexOf ( 'apples' ) == 0 ); To sort a list, use the sort() method. You can provide a sorting function that compares two objects: var fruits = [ 'bananas' , 'apples' , 'oranges' ]; // Sort a list. fruits . sort (( a , b ) => a . compareTo ( b )); assert ( fruits [ 0 ] == 'apples' ); Lists are parameterized types ( generics ), allowing you to specify the type of elements they should contain: // This list should contain only strings. var fruits = < String > []; fruits . add ( 'apples' ); var fruit = fruits [ 0 ]; assert ( fruit is String ); Note: In many cases, you don't need to explicitly specify generic types, as Dart will infer them for you. However, there are times when you should specify them, especially when Dart has nothing to infer from.","title":"Lists (List, also known as arrays)"},{"location":"1.1_types/#sets-set","text":"A set in Dart is an unordered collection of unique items. Sets do not support indexing. // Create an empty set of strings. var ingredients = < String > {}; // Add new items to it. ingredients . addAll ([ 'gold' , 'titanium' , 'xenon' ]); assert ( ingredients . length == 3 ); // Adding a duplicate item has no effect. ingredients . add ( 'gold' ); assert ( ingredients . length == 3 ); // Remove an item from a set. ingredients . remove ( 'gold' ); assert ( ingredients . length == 2 ); // You can also create sets using constructors. var atomicNumbers = Set . from ([ 79 , 22 , 54 ]); To check for the presence of one or more objects in a set, use contains() and containsAll() : var ingredients = Set < String > (); ingredients . addAll ([ 'gold' , 'titanium' , 'xenon' ]); // Check whether an item is in the set. assert ( ingredients . contains ( 'titanium' )); // Check whether all the items are in the set. assert ( ingredients . containsAll ([ 'titanium' , 'xenon' ]));","title":"Sets (Set)"},{"location":"1.1_types/#maps-map","text":"A map, commonly known as a dictionary or hash , is an unordered collection of key-value pairs. Maps associate a key to some value for easy retrieval. Unlike in JavaScript, Dart objects are not maps. You can declare a map using a terse literal syntax, or you can use a traditional constructor: // Maps often use strings as keys. var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; // Maps can be built from a constructor. var searchTerms = Map (); // Maps are parameterized types; you can specify what // types the key and value should be. var nobleGases = Map < int , String > (); You add, get, and set map items using the bracket syntax. Use remove() to remove a key and its value from a map. var nobleGases = { 54 : 'xenon' }; // Retrieve a value with a key. assert ( nobleGases [ 54 ] == 'xenon' ); // Check whether a map contains a key. assert ( nobleGases . containsKey ( 54 )); // Remove a key and its value. nobleGases . remove ( 54 ); assert ( ! nobleGases . containsKey ( 54 )); You can retrieve all the values or all the keys from a map: var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; // Get all the keys as an unordered collection // (an Iterable). var keys = hawaiianBeaches . keys ; assert ( keys . length == 3 ); assert ( Set . from ( keys ). contains ( 'Oahu' )); // Get all the values as an unordered collection // (an Iterable of Lists). var values = hawaiianBeaches . values ; assert ( values . length == 3 ); assert ( values . any (( v ) => v . contains ( 'Waikiki' ))); To check whether a map contains a key, use containsKey() . Because map values can be null, you cannot rely on simply getting the value for the key and checking for null to determine the existence of a key. var hawaiianBeaches = { 'Oahu' : [ 'Waikiki' , 'Kailua' , 'Waimanalo' ], 'Big Island' : [ 'Wailea Bay' , 'Pololu Beach' ], 'Kauai' : [ 'Hanalei' , 'Poipu' ] }; assert ( hawaiianBeaches . containsKey ( 'Oahu' )); assert ( ! hawaiianBeaches . containsKey ( 'Florida' )); Use the putIfAbsent() method when you want to assign a value to a key if and only if the key does not already exist in a map. You must provide a function that returns the value. var teamAssignments = < String , String > {}; teamAssignments . putIfAbsent ( 'Catcher' , () => pickToughestKid ()); assert ( teamAssignments [ 'Catcher' ] != null ); Refer to the [Map API reference][Map] for a full list of methods.","title":"Maps (Map)"},{"location":"1.1_types/#common-collection-methods","text":"List, Set, and Map share common functionality found in many collections. Some of this common functionality is defined by the Iterable class, which List and Set implement. {{site.alert.note}} Although Map doesn\u2019t implement Iterable, you can get Iterables from it using the Map keys and values properties. {{site.alert.end}} Use isEmpty or isNotEmpty to check whether a list, set, or map has items: var coffees = < String > []; var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; assert ( coffees . isEmpty ); assert ( teas . isNotEmpty ); To apply a function to each item in a list, set, or map, you can use forEach() : var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; teas . forEach (( tea ) => print ( 'I drink $ tea ' )); When you invoke forEach() on a map, your function must take two arguments (the key and value): hawaiianBeaches . forEach (( k , v ) { print ( 'I want to visit $ k and swim at $ v ' ); // I want to visit Oahu and swim at // [Waikiki, Kailua, Waimanalo], etc. }); Iterables provide the map() method, which gives you all the results in a single object: var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; var loudTeas = teas . map (( tea ) => tea . toUpperCase ()); loudTeas . forEach ( print ); {{site.alert.note}} The object returned by map() is an Iterable that\u2019s lazily evaluated : your function isn\u2019t called until you ask for an item from the returned object. {{site.alert.end}} To force your function to be called immediately on each item, use map().toList() or map().toSet() : var loudTeas = teas . map (( tea ) => tea . toUpperCase ()). toList (); Use Iterable\u2019s where() method to get all the items that match a condition. Use Iterable\u2019s any() and every() methods to check whether some or all items match a condition. {% comment %} PENDING: Change example as suggested by floitsch to have (maybe) cities instead of isDecaffeinated. var teas = [ 'green' , 'black' , 'chamomile' , 'earl grey' ]; // Chamomile is not caffeinated. bool isDecaffeinated ( String teaName ) => teaName == 'chamomile' ; // Use where() to find only the items that return true // from the provided function. var decaffeinatedTeas = teas . where (( tea ) => isDecaffeinated ( tea )); // or teas.where(isDecaffeinated) // Use any() to check whether at least one item in the // collection satisfies a condition. assert ( teas . any ( isDecaffeinated )); // Use every() to check whether all the items in a // collection satisfy a condition. assert ( ! teas . every ( isDecaffeinated ));","title":"Common collection methods"},{"location":"1.1_types/#runes-runes-often-replaced-by-the-characters-api","text":"Runes: In Dart, runes are integers representing Unicode code points. They are used to handle characters that are not in the basic ASCII range. Dart has a Runes class for manipulating them.","title":"Runes (Runes; often replaced by the characters API)"},{"location":"1.1_types/#symbols-symbol","text":"Symbols: In Dart, symbols are immutable, unique identifiers used mainly for reflection. Created using the # symbol, they allow you to access properties and methods dynamically.","title":"Symbols (Symbol)"},{"location":"1.1_types/#the-value-null-null","text":"The value null: In Dart, \"null\" indicates the absence of a value. It is the default value for variables that haven't been initialized and is used to represent the idea of \"nothing\" in the code.","title":"The value null (Null)"},{"location":"1.2_functions_controlFlow_errorHandling/","text":"Functions Loops Branches Error Handling","title":"1.2 Functions, Control Flow & Error Handling"},{"location":"1.2_functions_controlFlow_errorHandling/#functions","text":"","title":"Functions"},{"location":"1.2_functions_controlFlow_errorHandling/#loops","text":"","title":"Loops"},{"location":"1.2_functions_controlFlow_errorHandling/#branches","text":"","title":"Branches"},{"location":"1.2_functions_controlFlow_errorHandling/#error-handling","text":"","title":"Error Handling"},{"location":"1.3_oop/","text":"OOP Classes Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except Null descend from Object . Mixin-based inheritance means that although every class has exactly one superclass, a class body can be reused in multiple class hierarchies. Using class members Objects have members consisting of functions and data ( methods and instance variables , respectively). When you call a method, you invoke it on an object: the method has access to that object\u2019s functions and data. Use a dot ( . ) to refer to an instance variable or method: var p = Point ( 2 , 2 ); // Get the value of y. assert ( p . y == 2 ); // Invoke distanceTo() on p. double distance = p . distanceTo ( Point ( 4 , 4 )); Use ?. instead of . to avoid an exception when the leftmost operand is null: // If p is non-null, set a variable equal to its y value. var a = p ? . y ; Using constructors You can create an object using a constructor . Constructor names can be either ClassName or ClassName . identifier . For example, the following code creates Point objects using the Point() and Point.fromJson() constructors: var p1 = Point ( 2 , 2 ); var p2 = Point . fromJson ({ 'x' : 1 , 'y' : 2 }); The following code has the same effect, but uses the optional new keyword before the constructor name: var p1 = new Point ( 2 , 2 ); var p2 = new Point . fromJson ({ 'x' : 1 , 'y' : 2 }); Some classes provide [constant constructors][]. To create a compile-time constant using a constant constructor, put the const keyword before the constructor name: var p = const ImmutablePoint ( 2 , 2 ); Getting an object's type To get an object's type at runtime, you can use the Object property runtimeType , which returns a Type object. print ( 'The type of a is ${ a . runtimeType } ' ); Note: Use a type test operator rather than runtimeType to test an object's type. In production environments, the test object is Type is more stable than the test object.runtimeType == Type . Up to here, you've seen how to use classes. The rest of this section shows how to implement classes. Instance variables What are Instance Variables? Instance variables are variables that belong to an object (an instance of a class). They hold the data that represents the state of the object. How to Declare Instance Variables In Dart, you declare instance variables inside a class. You can also set their initial values. class Point { double ? x ; // x is initially null double ? y ; // y is initially null double z = 0 ; // z is initially 0 } Default Value If you don't set an initial value, the default value is null . Getters and Setters Dart automatically creates getter and setter methods for instance variables. You can use these to read or modify the value of an instance variable. void main () { var point = Point (); point . x = 4 ; // sets x to 4 print ( point . x ); // prints 4 } Final Instance Variables If you want a variable that can be set only once, you can use final . class ProfileMark { final String name ; final DateTime start = DateTime . now (); ProfileMark ( this . name ); } What are Implicit Interfaces? In Dart, every class you create also automatically defines an \"interface\". This interface includes all the methods and properties that the class has. It's like a blueprint of what the class can do, but without the actual code that performs the actions. Why Use Interfaces? Let's say you have a class B and you want to create another class A that can do everything B can do, but in a different way. In this case, class A can \"implement\" the interface of B . This means A will have to provide its own code for all the methods and properties that B has. How to Implement an Interface? You use the implements keyword to specify that a class should follow the blueprint of an interface. Then, you write the code for each method and property that the interface requires. Example Explained Here's a simple example: // This is a class called Person. It has a method called greet(). class Person { final String _name ; Person ( this . _name ); String greet ( String who ) => 'Hello, $ who . I am $ _name .' ; } // This is another class called Impostor. It \"implements\" Person. class Impostor implements Person { String get _name => '' ; String greet ( String who ) => 'Hi $ who . Do you know who I am?' ; } // This function takes a Person object and calls its greet() method. String greetBob ( Person person ) => person . greet ( 'Bob' ); In this example, Impostor is like a \"fake\" Person . It has to have a greet() method because it implements Person , but it can say something different. Multiple Interfaces A class can implement more than one interface. For example: class Point implements Comparable , Location { /*...*/ } Here, Point has to follow the blueprints of both Comparable and Location . Class Variables and Methods in Dart Use the static keyword to implement class-wide variables and methods. What are Static Variables? Static variables are variables that belong to the class itself, not to any specific instance of the class. You can think of them as \"shared\" variables that all instances of the class can access. You use the static keyword to declare them. For example, if you have a Queue class and you want all Queue objects to know the initial capacity, you can use a static variable: class Queue { static const initialCapacity = 16 ; } To access this variable, you use the class name: print ( Queue . initialCapacity ); // Output will be 16 Note: Static variables are only initialized when they are used for the first time. What are Static Methods? Static methods are methods that belong to the class, not to any specific instance. These methods can't access instance variables because they don't operate on an instance of the class. However, they can access static variables. For example, if you want a method to calculate the distance between two points, you can make it a static method: import 'dart:math' ; class Point { double x , y ; Point ( this . x , this . y ); static double distanceBetween ( Point a , Point b ) { var dx = a . x - b . x ; var dy = a . y - b . y ; return sqrt ( dx * dx + dy * dy ); } } To use this method, you call it on the class itself, not on an instance: var distance = Point . distanceBetween ( a , b ); When to Use Static Methods? Static methods are useful for utility functions that don't need to access any instance variables. Dart also allows you to use static methods as compile-time constants. I hope this makes the concept of static variables and methods clear! Would you like to know more about any specific part? Constructors What is a Constructor? A constructor is a special function in a class that helps create an object (instance) of that class. It usually initializes the instance variables. Basic Constructor Here's a simple constructor for a Point class: class Point { double x = 0 ; double y = 0 ; Point ( double x , double y ) { this . x = x ; this . y = y ; } } The this Keyword The this keyword refers to the current instance of the class. Use it only when you need to distinguish between instance variables and constructor parameters with the same name. Initializing Formal Parameters Dart has a shorthand for directly assigning constructor arguments to instance variables: class Point { final double x ; final double y ; Point ( this . x , this . y ); } Default Constructor If you don't define any constructor, Dart provides a default one with no arguments. The default constructor has no arguments and invokes the no-argument constructor in the superclass. Named Constructors You can have more than one constructor by giving them different names: class Point { final double x ; final double y ; Point ( this . x , this . y ); // Named constructor Point . origin () : x = 0 , y = 0 ; @override String toString () => \"( $ x , $ y )\" ; } void main () { var o = Point . origin (); var p = Point ( 2 , 3 ); print ( o ); // prints (0, 0) print ( p ); // prints (2, 3) } Superclass Constructors In a subclass, you can call a constructor from the superclass using super : class Employee extends Person { Employee () : super . fromJson ( fetchDefaultData ()); } Initializer List You can set initial values for instance variables before the constructor body runs: Point . fromJson ( Map < String , double > json ) : x = json [ 'x' ] ! , y = json [ 'y' ] ! { print ( 'In Point.fromJson(): ( $ x , $ y )' ); } Redirecting Constructors You can make a constructor redirect to another constructor in the same class: class Point { double x , y ; Point ( this . x , this . y ); Point . alongXAxis ( double x ) : this ( x , 0 ); } Constant Constructors For objects that never change, you can define a const constructor: class ImmutablePoint { final double x , y ; const ImmutablePoint ( this . x , this . y ); } Methods Methods are functions that provide behavior for an object. Instance methods Instance methods on objects can access instance variables and this . The distanceTo() method in the following sample is an example of an instance method: import 'dart:math' ; class Point { final double x ; final double y ; Point ( this . x , this . y ); double distanceTo ( Point other ) { var dx = x - other . x ; var dy = y - other . y ; return sqrt ( dx * dx + dy * dy ); } } Operators Dart allows you to define custom behavior for operators like + , - , == , etc. You use the operator keyword to define them. class Vector { final int x , y ; Vector ( this . x , this . y ); Vector operator + ( Vector v ) => Vector ( x + v . x , y + v . y ); Vector operator - ( Vector v ) => Vector ( x - v . x , y - v . y ); @override bool operator == ( Object other ) => other is Vector && x == other . x && y == other . y ; @override int get hashCode => Object . hash ( x , y ); } void main () { final v = Vector ( 2 , 3 ); final w = Vector ( 2 , 2 ); assert ( v + w == Vector ( 4 , 5 )); assert ( v - w == Vector ( 0 , 1 )); } Getters and Setters Getters and setters allow you to define custom behavior for reading and writing properties. Dart automatically provides getters and setters for instance variables, but you can override them. class Rectangle { double left , top , width , height ; Rectangle ( this . left , this . top , this . width , this . height ); // Define two calculated properties: right and bottom. double get right => left + width ; set right ( double value ) => left = value - width ; double get bottom => top + height ; set bottom ( double value ) => top = value - height ; } void main () { var rect = Rectangle ( 3 , 4 , 20 , 15 ); assert ( rect . left == 3 ); rect . right = 12 ; assert ( rect . left == - 8 ); } Abstract Methods Abstract methods define the structure of a method but don't provide an implementation. They can only exist in abstract classes. abstract class Doer { void doSomething (); // Abstract method } class EffectiveDoer extends Doer { void doSomething () { // Implementation here } } Inheritance Extend a Class To make a subclass, use extends . Use super to call the parent class: class TV { void turnOn () { // some code } } class SmartTV extends TV { void turnOn () { super . turnOn (); // extra code } } Override Members You can change methods, getters, and setters in subclasses with @override : class TV { set contrast ( int value ) {} } class SmartTV extends TV { @override set contrast ( num value ) {} } Rules for Overriding Return type must match or be a subtype. Argument types must match or be a supertype. Same number of positional parameters. Mixins What are Mixins? Mixins let you reuse code across multiple classes. Use the with keyword to include one or more mixins in a class. class Musician extends Performer with Musical { // ... } class Maestro extends Person with Musical , Aggressive , Demented { // ... } Defining a Mixin Use mixin to create a mixin. Mixins can't extend other classes and can't have constructors. mixin Musical { // ... } Restricting Mixin Usage Use on to specify which classes can use the mixin. mixin MusicalPerformer on Musician { // ... } Only classes that extend Musician can use MusicalPerformer . class , mixin , or mixin class ? mixin : Defines a mixin. class : Defines a class. mixin class : Usable as both a class and a mixin. Mixin Example mixin PythonProgrammer { void codePython () { print ( \"I Code in Python\" ); } } mixin DartProgrammer { void codeDart () { print ( \"I Code in Dart\" ); } } class COMP4768Student with PythonProgrammer , DartProgrammer { void buildApps () { print ( \"I can build mobile apps\" ); } } void main () { var student = COMP4768Student (); student . codePython (); // I Code in Python student . codeDart (); // I Code in Dart student . buildApps (); // I can build mobile apps } Abstract Mixin Class Make a mixin abstract to require certain methods to be implemented by any class that uses it. abstract mixin class Musician { void playInstrument ( String instrumentName ); // ... } This ensures the mixin has access to the methods it needs, similar to the on directive. For more details, check the Dart language guide . Certainly! Below is a summarized and rewritten version of the provided text about enumerated types, or enums, in Dart: Enumerated Types Enumerated types, also known as enums, are specialized classes in Dart that are designed to hold a fixed set of constant values. All enums in Dart inherently extend the Enum class and are sealed, which prevents them from being extended, implemented, or instantiated explicitly. Simple Enums You can define a simple enum using the enum keyword: enum Shade { light , medium , dark } Enhanced Enums Dart supports enhanced enums that allow you to declare classes with fields, methods, and constant constructors. The requirements for enhanced enums include: All instance variables must be final . All generative constructors must be const . Factory constructors can only return a known enum instance. No overrides for index , hashCode , or the == operator. Example: enum Transport implements Comparable < Transport > { car ( tires: 4 , passengers: 4 ), bike ( tires: 2 , passengers: 1 ); const Transport ({ required this . tires , required this . passengers }); final int tires ; final int passengers ; @override int compareTo ( Transport other ) => tires - other . tires ; } Using Enums Enums can be accessed like static variables: final chosenShade = Shade . dark ; You can also retrieve the index of an enum value: assert ( Shade . light . index == 0 ); You can iterate over all enum values using the values constant: List < Shade > allShades = Shade . values ; Enums can also be used in switch statements: var myShade = Shade . dark ; switch ( myShade ) { case Shade . light: print ( 'Light shade.' ); break ; case Shade . medium: print ( 'Medium shade.' ); break ; default : print ( myShade ); } To get the string name of an enum value, use the .name property: print ( Shade . dark . name ); // Output: 'dark' Methods and properties can be accessed just like in regular classes: print ( Transport . car . tires ); // Output: 4","title":"1.3 OOP"},{"location":"1.3_oop/#oop","text":"","title":"OOP"},{"location":"1.3_oop/#classes","text":"Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except Null descend from Object . Mixin-based inheritance means that although every class has exactly one superclass, a class body can be reused in multiple class hierarchies.","title":"Classes"},{"location":"1.3_oop/#using-class-members","text":"Objects have members consisting of functions and data ( methods and instance variables , respectively). When you call a method, you invoke it on an object: the method has access to that object\u2019s functions and data. Use a dot ( . ) to refer to an instance variable or method: var p = Point ( 2 , 2 ); // Get the value of y. assert ( p . y == 2 ); // Invoke distanceTo() on p. double distance = p . distanceTo ( Point ( 4 , 4 )); Use ?. instead of . to avoid an exception when the leftmost operand is null: // If p is non-null, set a variable equal to its y value. var a = p ? . y ;","title":"Using class members"},{"location":"1.3_oop/#using-constructors","text":"You can create an object using a constructor . Constructor names can be either ClassName or ClassName . identifier . For example, the following code creates Point objects using the Point() and Point.fromJson() constructors: var p1 = Point ( 2 , 2 ); var p2 = Point . fromJson ({ 'x' : 1 , 'y' : 2 }); The following code has the same effect, but uses the optional new keyword before the constructor name: var p1 = new Point ( 2 , 2 ); var p2 = new Point . fromJson ({ 'x' : 1 , 'y' : 2 }); Some classes provide [constant constructors][]. To create a compile-time constant using a constant constructor, put the const keyword before the constructor name: var p = const ImmutablePoint ( 2 , 2 );","title":"Using constructors"},{"location":"1.3_oop/#getting-an-objects-type","text":"To get an object's type at runtime, you can use the Object property runtimeType , which returns a Type object. print ( 'The type of a is ${ a . runtimeType } ' ); Note: Use a type test operator rather than runtimeType to test an object's type. In production environments, the test object is Type is more stable than the test object.runtimeType == Type . Up to here, you've seen how to use classes. The rest of this section shows how to implement classes.","title":"Getting an object's type"},{"location":"1.3_oop/#instance-variables","text":"","title":"Instance variables"},{"location":"1.3_oop/#what-are-instance-variables","text":"Instance variables are variables that belong to an object (an instance of a class). They hold the data that represents the state of the object.","title":"What are Instance Variables?"},{"location":"1.3_oop/#how-to-declare-instance-variables","text":"In Dart, you declare instance variables inside a class. You can also set their initial values. class Point { double ? x ; // x is initially null double ? y ; // y is initially null double z = 0 ; // z is initially 0 }","title":"How to Declare Instance Variables"},{"location":"1.3_oop/#default-value","text":"If you don't set an initial value, the default value is null .","title":"Default Value"},{"location":"1.3_oop/#getters-and-setters","text":"Dart automatically creates getter and setter methods for instance variables. You can use these to read or modify the value of an instance variable. void main () { var point = Point (); point . x = 4 ; // sets x to 4 print ( point . x ); // prints 4 }","title":"Getters and Setters"},{"location":"1.3_oop/#final-instance-variables","text":"If you want a variable that can be set only once, you can use final . class ProfileMark { final String name ; final DateTime start = DateTime . now (); ProfileMark ( this . name ); }","title":"Final Instance Variables"},{"location":"1.3_oop/#what-are-implicit-interfaces","text":"In Dart, every class you create also automatically defines an \"interface\". This interface includes all the methods and properties that the class has. It's like a blueprint of what the class can do, but without the actual code that performs the actions.","title":"What are Implicit Interfaces?"},{"location":"1.3_oop/#why-use-interfaces","text":"Let's say you have a class B and you want to create another class A that can do everything B can do, but in a different way. In this case, class A can \"implement\" the interface of B . This means A will have to provide its own code for all the methods and properties that B has.","title":"Why Use Interfaces?"},{"location":"1.3_oop/#how-to-implement-an-interface","text":"You use the implements keyword to specify that a class should follow the blueprint of an interface. Then, you write the code for each method and property that the interface requires.","title":"How to Implement an Interface?"},{"location":"1.3_oop/#example-explained","text":"Here's a simple example: // This is a class called Person. It has a method called greet(). class Person { final String _name ; Person ( this . _name ); String greet ( String who ) => 'Hello, $ who . I am $ _name .' ; } // This is another class called Impostor. It \"implements\" Person. class Impostor implements Person { String get _name => '' ; String greet ( String who ) => 'Hi $ who . Do you know who I am?' ; } // This function takes a Person object and calls its greet() method. String greetBob ( Person person ) => person . greet ( 'Bob' ); In this example, Impostor is like a \"fake\" Person . It has to have a greet() method because it implements Person , but it can say something different.","title":"Example Explained"},{"location":"1.3_oop/#multiple-interfaces","text":"A class can implement more than one interface. For example: class Point implements Comparable , Location { /*...*/ } Here, Point has to follow the blueprints of both Comparable and Location .","title":"Multiple Interfaces"},{"location":"1.3_oop/#class-variables-and-methods-in-dart","text":"Use the static keyword to implement class-wide variables and methods.","title":"Class Variables and Methods in Dart"},{"location":"1.3_oop/#what-are-static-variables","text":"Static variables are variables that belong to the class itself, not to any specific instance of the class. You can think of them as \"shared\" variables that all instances of the class can access. You use the static keyword to declare them. For example, if you have a Queue class and you want all Queue objects to know the initial capacity, you can use a static variable: class Queue { static const initialCapacity = 16 ; } To access this variable, you use the class name: print ( Queue . initialCapacity ); // Output will be 16 Note: Static variables are only initialized when they are used for the first time.","title":"What are Static Variables?"},{"location":"1.3_oop/#what-are-static-methods","text":"Static methods are methods that belong to the class, not to any specific instance. These methods can't access instance variables because they don't operate on an instance of the class. However, they can access static variables. For example, if you want a method to calculate the distance between two points, you can make it a static method: import 'dart:math' ; class Point { double x , y ; Point ( this . x , this . y ); static double distanceBetween ( Point a , Point b ) { var dx = a . x - b . x ; var dy = a . y - b . y ; return sqrt ( dx * dx + dy * dy ); } } To use this method, you call it on the class itself, not on an instance: var distance = Point . distanceBetween ( a , b );","title":"What are Static Methods?"},{"location":"1.3_oop/#when-to-use-static-methods","text":"Static methods are useful for utility functions that don't need to access any instance variables. Dart also allows you to use static methods as compile-time constants. I hope this makes the concept of static variables and methods clear! Would you like to know more about any specific part?","title":"When to Use Static Methods?"},{"location":"1.3_oop/#constructors","text":"","title":"Constructors"},{"location":"1.3_oop/#what-is-a-constructor","text":"A constructor is a special function in a class that helps create an object (instance) of that class. It usually initializes the instance variables.","title":"What is a Constructor?"},{"location":"1.3_oop/#basic-constructor","text":"Here's a simple constructor for a Point class: class Point { double x = 0 ; double y = 0 ; Point ( double x , double y ) { this . x = x ; this . y = y ; } }","title":"Basic Constructor"},{"location":"1.3_oop/#the-this-keyword","text":"The this keyword refers to the current instance of the class. Use it only when you need to distinguish between instance variables and constructor parameters with the same name.","title":"The this Keyword"},{"location":"1.3_oop/#initializing-formal-parameters","text":"Dart has a shorthand for directly assigning constructor arguments to instance variables: class Point { final double x ; final double y ; Point ( this . x , this . y ); }","title":"Initializing Formal Parameters"},{"location":"1.3_oop/#default-constructor","text":"If you don't define any constructor, Dart provides a default one with no arguments. The default constructor has no arguments and invokes the no-argument constructor in the superclass.","title":"Default Constructor"},{"location":"1.3_oop/#named-constructors","text":"You can have more than one constructor by giving them different names: class Point { final double x ; final double y ; Point ( this . x , this . y ); // Named constructor Point . origin () : x = 0 , y = 0 ; @override String toString () => \"( $ x , $ y )\" ; } void main () { var o = Point . origin (); var p = Point ( 2 , 3 ); print ( o ); // prints (0, 0) print ( p ); // prints (2, 3) }","title":"Named Constructors"},{"location":"1.3_oop/#superclass-constructors","text":"In a subclass, you can call a constructor from the superclass using super : class Employee extends Person { Employee () : super . fromJson ( fetchDefaultData ()); }","title":"Superclass Constructors"},{"location":"1.3_oop/#initializer-list","text":"You can set initial values for instance variables before the constructor body runs: Point . fromJson ( Map < String , double > json ) : x = json [ 'x' ] ! , y = json [ 'y' ] ! { print ( 'In Point.fromJson(): ( $ x , $ y )' ); }","title":"Initializer List"},{"location":"1.3_oop/#redirecting-constructors","text":"You can make a constructor redirect to another constructor in the same class: class Point { double x , y ; Point ( this . x , this . y ); Point . alongXAxis ( double x ) : this ( x , 0 ); }","title":"Redirecting Constructors"},{"location":"1.3_oop/#constant-constructors","text":"For objects that never change, you can define a const constructor: class ImmutablePoint { final double x , y ; const ImmutablePoint ( this . x , this . y ); }","title":"Constant Constructors"},{"location":"1.3_oop/#methods","text":"Methods are functions that provide behavior for an object.","title":"Methods"},{"location":"1.3_oop/#instance-methods","text":"Instance methods on objects can access instance variables and this . The distanceTo() method in the following sample is an example of an instance method: import 'dart:math' ; class Point { final double x ; final double y ; Point ( this . x , this . y ); double distanceTo ( Point other ) { var dx = x - other . x ; var dy = y - other . y ; return sqrt ( dx * dx + dy * dy ); } }","title":"Instance methods"},{"location":"1.3_oop/#operators","text":"Dart allows you to define custom behavior for operators like + , - , == , etc. You use the operator keyword to define them. class Vector { final int x , y ; Vector ( this . x , this . y ); Vector operator + ( Vector v ) => Vector ( x + v . x , y + v . y ); Vector operator - ( Vector v ) => Vector ( x - v . x , y - v . y ); @override bool operator == ( Object other ) => other is Vector && x == other . x && y == other . y ; @override int get hashCode => Object . hash ( x , y ); } void main () { final v = Vector ( 2 , 3 ); final w = Vector ( 2 , 2 ); assert ( v + w == Vector ( 4 , 5 )); assert ( v - w == Vector ( 0 , 1 )); }","title":"Operators"},{"location":"1.3_oop/#getters-and-setters_1","text":"Getters and setters allow you to define custom behavior for reading and writing properties. Dart automatically provides getters and setters for instance variables, but you can override them. class Rectangle { double left , top , width , height ; Rectangle ( this . left , this . top , this . width , this . height ); // Define two calculated properties: right and bottom. double get right => left + width ; set right ( double value ) => left = value - width ; double get bottom => top + height ; set bottom ( double value ) => top = value - height ; } void main () { var rect = Rectangle ( 3 , 4 , 20 , 15 ); assert ( rect . left == 3 ); rect . right = 12 ; assert ( rect . left == - 8 ); }","title":"Getters and Setters"},{"location":"1.3_oop/#abstract-methods","text":"Abstract methods define the structure of a method but don't provide an implementation. They can only exist in abstract classes. abstract class Doer { void doSomething (); // Abstract method } class EffectiveDoer extends Doer { void doSomething () { // Implementation here } }","title":"Abstract Methods"},{"location":"1.3_oop/#inheritance","text":"","title":"Inheritance"},{"location":"1.3_oop/#extend-a-class","text":"To make a subclass, use extends . Use super to call the parent class: class TV { void turnOn () { // some code } } class SmartTV extends TV { void turnOn () { super . turnOn (); // extra code } }","title":"Extend a Class"},{"location":"1.3_oop/#override-members","text":"You can change methods, getters, and setters in subclasses with @override : class TV { set contrast ( int value ) {} } class SmartTV extends TV { @override set contrast ( num value ) {} }","title":"Override Members"},{"location":"1.3_oop/#rules-for-overriding","text":"Return type must match or be a subtype. Argument types must match or be a supertype. Same number of positional parameters.","title":"Rules for Overriding"},{"location":"1.3_oop/#mixins","text":"","title":"Mixins"},{"location":"1.3_oop/#what-are-mixins","text":"Mixins let you reuse code across multiple classes. Use the with keyword to include one or more mixins in a class. class Musician extends Performer with Musical { // ... } class Maestro extends Person with Musical , Aggressive , Demented { // ... }","title":"What are Mixins?"},{"location":"1.3_oop/#defining-a-mixin","text":"Use mixin to create a mixin. Mixins can't extend other classes and can't have constructors. mixin Musical { // ... }","title":"Defining a Mixin"},{"location":"1.3_oop/#restricting-mixin-usage","text":"Use on to specify which classes can use the mixin. mixin MusicalPerformer on Musician { // ... } Only classes that extend Musician can use MusicalPerformer .","title":"Restricting Mixin Usage"},{"location":"1.3_oop/#class-mixin-or-mixin-class","text":"mixin : Defines a mixin. class : Defines a class. mixin class : Usable as both a class and a mixin.","title":"class, mixin, or mixin class?"},{"location":"1.3_oop/#mixin-example","text":"mixin PythonProgrammer { void codePython () { print ( \"I Code in Python\" ); } } mixin DartProgrammer { void codeDart () { print ( \"I Code in Dart\" ); } } class COMP4768Student with PythonProgrammer , DartProgrammer { void buildApps () { print ( \"I can build mobile apps\" ); } } void main () { var student = COMP4768Student (); student . codePython (); // I Code in Python student . codeDart (); // I Code in Dart student . buildApps (); // I can build mobile apps }","title":"Mixin Example"},{"location":"1.3_oop/#abstract-mixin-class","text":"Make a mixin abstract to require certain methods to be implemented by any class that uses it. abstract mixin class Musician { void playInstrument ( String instrumentName ); // ... } This ensures the mixin has access to the methods it needs, similar to the on directive. For more details, check the Dart language guide . Certainly! Below is a summarized and rewritten version of the provided text about enumerated types, or enums, in Dart:","title":"Abstract Mixin Class"},{"location":"1.3_oop/#enumerated-types","text":"Enumerated types, also known as enums, are specialized classes in Dart that are designed to hold a fixed set of constant values. All enums in Dart inherently extend the Enum class and are sealed, which prevents them from being extended, implemented, or instantiated explicitly.","title":"Enumerated Types"},{"location":"1.3_oop/#simple-enums","text":"You can define a simple enum using the enum keyword: enum Shade { light , medium , dark }","title":"Simple Enums"},{"location":"1.3_oop/#enhanced-enums","text":"Dart supports enhanced enums that allow you to declare classes with fields, methods, and constant constructors. The requirements for enhanced enums include: All instance variables must be final . All generative constructors must be const . Factory constructors can only return a known enum instance. No overrides for index , hashCode , or the == operator. Example: enum Transport implements Comparable < Transport > { car ( tires: 4 , passengers: 4 ), bike ( tires: 2 , passengers: 1 ); const Transport ({ required this . tires , required this . passengers }); final int tires ; final int passengers ; @override int compareTo ( Transport other ) => tires - other . tires ; }","title":"Enhanced Enums"},{"location":"1.3_oop/#using-enums","text":"Enums can be accessed like static variables: final chosenShade = Shade . dark ; You can also retrieve the index of an enum value: assert ( Shade . light . index == 0 ); You can iterate over all enum values using the values constant: List < Shade > allShades = Shade . values ; Enums can also be used in switch statements: var myShade = Shade . dark ; switch ( myShade ) { case Shade . light: print ( 'Light shade.' ); break ; case Shade . medium: print ( 'Medium shade.' ); break ; default : print ( myShade ); } To get the string name of an enum value, use the .name property: print ( Shade . dark . name ); // Output: 'dark' Methods and properties can be accessed just like in regular classes: print ( Transport . car . tires ); // Output: 4","title":"Using Enums"},{"location":"1.4_async/","text":"Asynchronous programming: futures, async, and await In Class Slides Introduction In this weather application, tapping the \"Get Temperature\" button initiates an asynchronous request to the OpenWeatherAPI servers. The app uses the API key to fetch current weather data for the city name entered by the user. Once the data is received, it updates the user interface without affecting the app's responsiveness. If all operations were carried out synchronously, the app could become unresponsive while waiting for the data to be fetched, leading to a subpar user experience. ElevatedButton ( onPressed: () async { Weather w = await WeatherFactory ( OPENWEATHER_API_KEY ) . currentWeatherByCityName ( cityNameController . text ); print ( w . temperature ! . celsius ? . toString ()); setState (() { weatherInfo = w ; }); }, child: Text ( 'Get Temperature' ), ) By using asynchronous programming constructs like async and await , the application performs the IO-bound work in the background. This means that the UI remains responsive, allowing users to interact with other parts of the application while the data is being fetched. Dart libraries have many functions that give back Future or Stream objects. These functions are quick to respond because they start a task that might take time (like reading a file) but don't wait for it to finish. They let your program keep running other things while waiting for the task to complete. The async and await keywords help you write code that can do multiple things at once, but the code still looks and reads like regular, one-thing-at-a-time (or sequential) code. Futures What is a Future? A Future is a Dart class that represents the outcome of an asynchronous operation. It can be in one of two states: either waiting for a result (Uncompleted) or having a result (Completed). States of a Future Uncompleted : When you call an async function, it gives you a Future that is waiting for the operation to finish or fail. Completed : The Future is done and holds either a value or an error. Types of Completion With Value : A Future of type Future<T> holds a value of type T . For example, Future<String> will have a string value. With Error : If the async operation fails, the Future holds an error. Examples Basic Example Here's a simple example where fetchUserOrder() returns a Future that completes after a delay. It doesn't return a value, so its type is Future<void> . Future < void > fetchUserOrder () { return Future . delayed ( Duration ( seconds: 2 ), () => print ( 'Large Latte' )); } void main () { fetchUserOrder (); print ( 'Fetching user order...' ); } In this example, \"Fetching user order...\" will print before \"Large Latte\" because of the delay in fetchUserOrder() . Error Example In the following example, fetchUserOrder() completes with an error. Future < void > fetchUserOrder () { return Future . delayed ( Duration ( seconds: 2 ), () => throw Exception ( 'Logout failed: user ID is invalid' )); } void main () { fetchUserOrder (); print ( 'Fetching user order...' ); } Here, the Future completes with an error about an invalid user ID. Quick Summary A Future<T> holds a value of type T . If it doesn't hold a value, its type is Future<void> . A Future can be either waiting for a result or completed with a value or an error. That's the basics of Futures in Dart. You'll learn how to use them effectively with async and await in the next section. Using async and await 3 Tasks example In this example, there are three tasks. Task 2 utilizes the Future.delayed function, which causes Task 2 to wait asynchronously. The words \"Task 2 complete\" is only printed once the waiting period is over. What happens if Task 3 has to wait for Task 2 to finish In the following example, since task3 does not wait for task2 to finish executing, the output does not include the task2Data. To solve this problem, we need to ask task3 to wait for task2 to finish executing. Lets use await to wait for the future to complete Now we will add await and async to make sure we wait for the future to complete and only then call task3 with the data returned from task2. Useful Links CodeLab Asynchrony support Concurrency in Dart Official YouTube Series on Async in Dart","title":"1.4 Async"},{"location":"1.4_async/#asynchronous-programming-futures-async-and-await","text":"In Class Slides","title":"Asynchronous programming: futures, async, and await"},{"location":"1.4_async/#introduction","text":"In this weather application, tapping the \"Get Temperature\" button initiates an asynchronous request to the OpenWeatherAPI servers. The app uses the API key to fetch current weather data for the city name entered by the user. Once the data is received, it updates the user interface without affecting the app's responsiveness. If all operations were carried out synchronously, the app could become unresponsive while waiting for the data to be fetched, leading to a subpar user experience. ElevatedButton ( onPressed: () async { Weather w = await WeatherFactory ( OPENWEATHER_API_KEY ) . currentWeatherByCityName ( cityNameController . text ); print ( w . temperature ! . celsius ? . toString ()); setState (() { weatherInfo = w ; }); }, child: Text ( 'Get Temperature' ), ) By using asynchronous programming constructs like async and await , the application performs the IO-bound work in the background. This means that the UI remains responsive, allowing users to interact with other parts of the application while the data is being fetched. Dart libraries have many functions that give back Future or Stream objects. These functions are quick to respond because they start a task that might take time (like reading a file) but don't wait for it to finish. They let your program keep running other things while waiting for the task to complete. The async and await keywords help you write code that can do multiple things at once, but the code still looks and reads like regular, one-thing-at-a-time (or sequential) code.","title":"Introduction"},{"location":"1.4_async/#futures","text":"","title":"Futures"},{"location":"1.4_async/#what-is-a-future","text":"A Future is a Dart class that represents the outcome of an asynchronous operation. It can be in one of two states: either waiting for a result (Uncompleted) or having a result (Completed).","title":"What is a Future?"},{"location":"1.4_async/#states-of-a-future","text":"Uncompleted : When you call an async function, it gives you a Future that is waiting for the operation to finish or fail. Completed : The Future is done and holds either a value or an error.","title":"States of a Future"},{"location":"1.4_async/#types-of-completion","text":"With Value : A Future of type Future<T> holds a value of type T . For example, Future<String> will have a string value. With Error : If the async operation fails, the Future holds an error.","title":"Types of Completion"},{"location":"1.4_async/#examples","text":"","title":"Examples"},{"location":"1.4_async/#basic-example","text":"Here's a simple example where fetchUserOrder() returns a Future that completes after a delay. It doesn't return a value, so its type is Future<void> . Future < void > fetchUserOrder () { return Future . delayed ( Duration ( seconds: 2 ), () => print ( 'Large Latte' )); } void main () { fetchUserOrder (); print ( 'Fetching user order...' ); } In this example, \"Fetching user order...\" will print before \"Large Latte\" because of the delay in fetchUserOrder() .","title":"Basic Example"},{"location":"1.4_async/#error-example","text":"In the following example, fetchUserOrder() completes with an error. Future < void > fetchUserOrder () { return Future . delayed ( Duration ( seconds: 2 ), () => throw Exception ( 'Logout failed: user ID is invalid' )); } void main () { fetchUserOrder (); print ( 'Fetching user order...' ); } Here, the Future completes with an error about an invalid user ID.","title":"Error Example"},{"location":"1.4_async/#quick-summary","text":"A Future<T> holds a value of type T . If it doesn't hold a value, its type is Future<void> . A Future can be either waiting for a result or completed with a value or an error. That's the basics of Futures in Dart. You'll learn how to use them effectively with async and await in the next section.","title":"Quick Summary"},{"location":"1.4_async/#using-async-and-await","text":"","title":"Using async and await"},{"location":"1.4_async/#3-tasks-example","text":"In this example, there are three tasks. Task 2 utilizes the Future.delayed function, which causes Task 2 to wait asynchronously. The words \"Task 2 complete\" is only printed once the waiting period is over.","title":"3 Tasks example"},{"location":"1.4_async/#what-happens-if-task-3-has-to-wait-for-task-2-to-finish","text":"In the following example, since task3 does not wait for task2 to finish executing, the output does not include the task2Data. To solve this problem, we need to ask task3 to wait for task2 to finish executing.","title":"What happens if Task 3 has to wait for Task 2 to finish"},{"location":"1.4_async/#lets-use-await-to-wait-for-the-future-to-complete","text":"Now we will add await and async to make sure we wait for the future to complete and only then call task3 with the data returned from task2. Useful Links CodeLab Asynchrony support Concurrency in Dart Official YouTube Series on Async in Dart","title":"Lets use await to wait for the future to complete"},{"location":"1.4_routing/","text":"","title":"1.4 routing"},{"location":"1.5_null_safety/","text":"Null Safety","title":"1.5 Null Safety"},{"location":"1.5_null_safety/#null-safety","text":"","title":"Null Safety"},{"location":"1.9_pratice_questions/","text":"Sample Questions Postal Codes In a Canadian postal code, the first, third, and fifth characters are letters, while the second, fourth, and sixth characters are numbers. The province can be determined from the first character of a postal code, as shown in the following table. No valid postal codes currently begin with D, F, I, O, Q, U, W, or Z. Province First character(s) Newfoundland A Nova Scotia B Prince Edward Island C New Brunswick E Quebec G, H, and J Ontario K, L, M, N, and P Manitoba R Saskatchewan S Alberta T British Columbia V Nunavut X Northwest Territories X Yukon Y The second character in a postal code identifies whether the address is rural or urban. If that character is a '0', then the address is rural. Otherwise, it is urban. Write a Dart function that takes a postal code as an argument and returns the province name along with whether the address is urban or rural. For example, if the function receives 'T2N 1N4', it should return that the postal code is for an urban address in Alberta. If it receives 'X0A 1B2', it should return that the postal code is for a rural address in Nunavut or Northwest Territories. Use a Map to map from the first character of the postal code to the province name. Display a meaningful error message if the postal code begins with an invalid character. Solution Converting Between Human Years and Dog Years Problem Statement: It's commonly said that one human year is equivalent to 7 dog years. However, this simple conversion doesn't account for the fact that dogs reach adulthood in about two years. To make the conversion more accurate, some suggest counting each of the first two human years as 10.5 dog years, and each additional human year as 4 dog years. Your task is to write a Dart program that performs conversions between human years and dog years. Requirements: Create a function named humanToDogYears that takes a double representing the human years and returns a double representing the equivalent dog years. Create another function named dogToHumanYears that takes a double representing the dog years and returns a double representing the equivalent human years. Both functions should handle the following scenarios: For humanToDogYears : For conversions of less than two human years, each human year should be counted as 10.5 dog years. For conversions of two or more human years, the first two years should be counted as 21 dog years (10.5 * 2), and each additional year should be counted as 4 dog years. For dogToHumanYears : For conversions of less than or equal to 21 dog years, each dog year should be counted as 1/10.5 human years. For conversions of more than 21 dog years, the first 21 dog years should be counted as 2 human years, and each additional dog year should be counted as 1/4 human years. If the user enters a negative number in either function, the function should display an appropriate error message and return -1 . Test Cases: void main () { // Test the functions with different years print ( humanToDogYears ( 1 )); // Should print 10.5 print ( humanToDogYears ( 2 )); // Should print 21.0 print ( humanToDogYears ( 3 )); // Should print 25.0 print ( humanToDogYears ( - 1 )); // Should print \"Invalid input. Please enter a non-negative number.\" print ( dogToHumanYears ( 10.5 )); // Should print 1.0 print ( dogToHumanYears ( 21 )); // Should print 2.0 print ( dogToHumanYears ( 25 )); // Should print 3.0 print ( dogToHumanYears ( - 1 )); // Should print \"Invalid input. Please enter a non-negative number.\" } Solution","title":"1.9 Practice Questions"},{"location":"1.9_pratice_questions/#sample-questions","text":"","title":"Sample Questions"},{"location":"1.9_pratice_questions/#postal-codes","text":"In a Canadian postal code, the first, third, and fifth characters are letters, while the second, fourth, and sixth characters are numbers. The province can be determined from the first character of a postal code, as shown in the following table. No valid postal codes currently begin with D, F, I, O, Q, U, W, or Z. Province First character(s) Newfoundland A Nova Scotia B Prince Edward Island C New Brunswick E Quebec G, H, and J Ontario K, L, M, N, and P Manitoba R Saskatchewan S Alberta T British Columbia V Nunavut X Northwest Territories X Yukon Y The second character in a postal code identifies whether the address is rural or urban. If that character is a '0', then the address is rural. Otherwise, it is urban. Write a Dart function that takes a postal code as an argument and returns the province name along with whether the address is urban or rural. For example, if the function receives 'T2N 1N4', it should return that the postal code is for an urban address in Alberta. If it receives 'X0A 1B2', it should return that the postal code is for a rural address in Nunavut or Northwest Territories. Use a Map to map from the first character of the postal code to the province name. Display a meaningful error message if the postal code begins with an invalid character. Solution","title":"Postal Codes"},{"location":"1.9_pratice_questions/#converting-between-human-years-and-dog-years","text":"","title":"Converting Between Human Years and Dog Years"},{"location":"1.9_pratice_questions/#problem-statement","text":"It's commonly said that one human year is equivalent to 7 dog years. However, this simple conversion doesn't account for the fact that dogs reach adulthood in about two years. To make the conversion more accurate, some suggest counting each of the first two human years as 10.5 dog years, and each additional human year as 4 dog years. Your task is to write a Dart program that performs conversions between human years and dog years.","title":"Problem Statement:"},{"location":"1.9_pratice_questions/#requirements","text":"Create a function named humanToDogYears that takes a double representing the human years and returns a double representing the equivalent dog years. Create another function named dogToHumanYears that takes a double representing the dog years and returns a double representing the equivalent human years. Both functions should handle the following scenarios: For humanToDogYears : For conversions of less than two human years, each human year should be counted as 10.5 dog years. For conversions of two or more human years, the first two years should be counted as 21 dog years (10.5 * 2), and each additional year should be counted as 4 dog years. For dogToHumanYears : For conversions of less than or equal to 21 dog years, each dog year should be counted as 1/10.5 human years. For conversions of more than 21 dog years, the first 21 dog years should be counted as 2 human years, and each additional dog year should be counted as 1/4 human years. If the user enters a negative number in either function, the function should display an appropriate error message and return -1 .","title":"Requirements:"},{"location":"1.9_pratice_questions/#test-cases","text":"void main () { // Test the functions with different years print ( humanToDogYears ( 1 )); // Should print 10.5 print ( humanToDogYears ( 2 )); // Should print 21.0 print ( humanToDogYears ( 3 )); // Should print 25.0 print ( humanToDogYears ( - 1 )); // Should print \"Invalid input. Please enter a non-negative number.\" print ( dogToHumanYears ( 10.5 )); // Should print 1.0 print ( dogToHumanYears ( 21 )); // Should print 2.0 print ( dogToHumanYears ( 25 )); // Should print 3.0 print ( dogToHumanYears ( - 1 )); // Should print \"Invalid input. Please enter a non-negative number.\" } Solution","title":"Test Cases:"},{"location":"2.2_managing_state/","text":"Managing State in Flutter Note : We are not following the code in the video as it uses RiverPod which is a bit more advanced. See this for comparison of various state. Instead we will use a more popular and user-friendly packaged called provider . Step 0: Add the provider package Run flutter pub add provider in Android Studio's terminal to install the provider package. More details here Step 1: Create a separate class to store the _taskCompletedCount In this step, we are creating a class named TaskCounterModel to keep track of the number of tasks completed. This class uses Flutter's ChangeNotifier to update the UI whenever the task count changes. class TaskCounterModel extends ChangeNotifier { int _taskCompletedCount = 0 ; int get tasksCompleted => _taskCompletedCount ; void increment () { _taskCompletedCount ++ ; notifyListeners (); } void decrement () { _taskCompletedCount -- ; notifyListeners (); } } Step 2: Wrap the entire App inside a ChangeNotiferProvider In this step, we are wrapping our main app inside a ChangeNotifierProvider . This allows us to make the TaskCounterModel available throughout the app for state management. Convert the following void main () => runApp ( MyApp ()); to import 'package:provider/provider.dart' ; void main () => runApp ( ChangeNotifierProvider ( create: ( context ) => TaskCounterModel (), child: MyApp (), ), ); Step 3: Get the checkboxes to update the information Here, we modify the TaskItem widget to use Consumer for listening to changes in TaskCounterModel . When a checkbox is toggled, it will either increment or decrement the task completed count. Replace the top code with the bottom code class _TaskItemState extends State < TaskItem > { bool ? _value = false ; @override Widget build ( BuildContext context ) { return Row ( children: [ Checkbox ( onChanged: ( newValue ) => setState (() => _value = newValue ), value: _value , ), Text ( widget . label ), ], ); } } class _TaskItemState extends State < TaskItem > { bool ? _value = false ; @override Widget build ( BuildContext context ) { return Consumer < TaskCounterModel > ( builder: ( context , value , child ) => Row ( children: [ Checkbox ( onChanged: ( newValue ) => setState (() { _value = newValue ; if ( newValue ! ) { value . increment (); } else { value . decrement (); } }), value: _value , ), Text ( widget . label ), ], ), ); } } Step 4: Get the progressbar( LinearProgressIndicator ) to Consume the information In this final step, we update the Progress widget to consume the task completed count from TaskCounterModel . The LinearProgressIndicator will now reflect the progress based on the number of tasks completed. Replace the top code with the bottom code class Progress extends StatelessWidget { @override Widget build ( BuildContext context ) { return Column ( children: [ Text ( 'You are this far away from exploring the whole universe:' ), LinearProgressIndicator ( value: 0.0 ), ], ); } } class Progress extends StatelessWidget { @override Widget build ( BuildContext context ) { return Consumer < TaskCounterModel > ( builder: ( context , value , child ) => Column ( children: [ Text ( 'You are this far away from exploring the whole universe:' ), LinearProgressIndicator ( value: value . tasksCompleted / 5 ), ], ), ); } }","title":"Managing State in Flutter"},{"location":"2.2_managing_state/#managing-state-in-flutter","text":"Note : We are not following the code in the video as it uses RiverPod which is a bit more advanced. See this for comparison of various state. Instead we will use a more popular and user-friendly packaged called provider .","title":"Managing State in Flutter"},{"location":"2.2_managing_state/#step-0-add-the-provider-package","text":"Run flutter pub add provider in Android Studio's terminal to install the provider package. More details here","title":"Step 0: Add the provider package"},{"location":"2.2_managing_state/#step-1-create-a-separate-class-to-store-the-_taskcompletedcount","text":"In this step, we are creating a class named TaskCounterModel to keep track of the number of tasks completed. This class uses Flutter's ChangeNotifier to update the UI whenever the task count changes. class TaskCounterModel extends ChangeNotifier { int _taskCompletedCount = 0 ; int get tasksCompleted => _taskCompletedCount ; void increment () { _taskCompletedCount ++ ; notifyListeners (); } void decrement () { _taskCompletedCount -- ; notifyListeners (); } }","title":"Step 1: Create a separate class to store the _taskCompletedCount"},{"location":"2.2_managing_state/#step-2-wrap-the-entire-app-inside-a-changenotiferprovider","text":"In this step, we are wrapping our main app inside a ChangeNotifierProvider . This allows us to make the TaskCounterModel available throughout the app for state management. Convert the following void main () => runApp ( MyApp ()); to import 'package:provider/provider.dart' ; void main () => runApp ( ChangeNotifierProvider ( create: ( context ) => TaskCounterModel (), child: MyApp (), ), );","title":"Step 2: Wrap the entire App inside a ChangeNotiferProvider"},{"location":"2.2_managing_state/#step-3-get-the-checkboxes-to-update-the-information","text":"Here, we modify the TaskItem widget to use Consumer for listening to changes in TaskCounterModel . When a checkbox is toggled, it will either increment or decrement the task completed count. Replace the top code with the bottom code class _TaskItemState extends State < TaskItem > { bool ? _value = false ; @override Widget build ( BuildContext context ) { return Row ( children: [ Checkbox ( onChanged: ( newValue ) => setState (() => _value = newValue ), value: _value , ), Text ( widget . label ), ], ); } } class _TaskItemState extends State < TaskItem > { bool ? _value = false ; @override Widget build ( BuildContext context ) { return Consumer < TaskCounterModel > ( builder: ( context , value , child ) => Row ( children: [ Checkbox ( onChanged: ( newValue ) => setState (() { _value = newValue ; if ( newValue ! ) { value . increment (); } else { value . decrement (); } }), value: _value , ), Text ( widget . label ), ], ), ); } }","title":"Step 3: Get the checkboxes to update the information"},{"location":"2.2_managing_state/#step-4-get-the-progressbarlinearprogressindicator-to-consume-the-information","text":"In this final step, we update the Progress widget to consume the task completed count from TaskCounterModel . The LinearProgressIndicator will now reflect the progress based on the number of tasks completed. Replace the top code with the bottom code class Progress extends StatelessWidget { @override Widget build ( BuildContext context ) { return Column ( children: [ Text ( 'You are this far away from exploring the whole universe:' ), LinearProgressIndicator ( value: 0.0 ), ], ); } } class Progress extends StatelessWidget { @override Widget build ( BuildContext context ) { return Consumer < TaskCounterModel > ( builder: ( context , value , child ) => Column ( children: [ Text ( 'You are this far away from exploring the whole universe:' ), LinearProgressIndicator ( value: value . tasksCompleted / 5 ), ], ), ); } }","title":"Step 4: Get the progressbar(LinearProgressIndicator) to Consume the information"},{"location":"8.1_assignment_1/","text":"COMP4768 Assignment 1: Introduction to Flutter","title":"COMP4768 Assignment 1: Introduction to Flutter"},{"location":"8.1_assignment_1/#comp4768-assignment-1-introduction-to-flutter","text":"","title":"COMP4768 Assignment 1: Introduction to Flutter"},{"location":"9.1_how_to_git/","text":"Flutter Project with Git and GitHub: A Step-by-Step Guide Prerequisites Make sure you have Flutter and Git installed on your system. Create a GitHub account if you haven't already. Install PyCharm IDE for Flutter development. Step 1: Create a New Flutter Project Open your terminal. Navigate to the directory where you want to create your new Flutter project. Run the following command to create a new Flutter project: flutter create demo_project Step 2: Navigate to the Project Directory Change the directory to the newly created Flutter project: cd demo_project Step 3: Initialize a Git Repository Initialize a new Git repository in your project directory: git init Step 4: Add Files to Git and Make Initial Commit Add all the project files to the Git repository: git add . Make your initial commit: git commit -m \"Initial commit\" Step 5: Link to GitHub Repository Go to GitHub and create a new repository named demo_project . Copy the repository URL. Link your local repository to the GitHub repository: git remote add origin https://github.com/yourusername/demo_project.git Step 6: Rename the Default Branch (Optional) Rename your default branch to main (this is optional and based on your preference): git branch -M main Step 7: Push to GitHub Push your local repository to GitHub: git push -u origin main Step 8: Open Project in PyCharm Open PyCharm. Go to File > Open . Navigate to your demo_project directory and select it. Click Open .","title":"A: How to Git"},{"location":"9.1_how_to_git/#flutter-project-with-git-and-github-a-step-by-step-guide","text":"","title":"Flutter Project with Git and GitHub: A Step-by-Step Guide"},{"location":"9.1_how_to_git/#prerequisites","text":"Make sure you have Flutter and Git installed on your system. Create a GitHub account if you haven't already. Install PyCharm IDE for Flutter development.","title":"Prerequisites"},{"location":"9.1_how_to_git/#step-1-create-a-new-flutter-project","text":"Open your terminal. Navigate to the directory where you want to create your new Flutter project. Run the following command to create a new Flutter project: flutter create demo_project","title":"Step 1: Create a New Flutter Project"},{"location":"9.1_how_to_git/#step-2-navigate-to-the-project-directory","text":"Change the directory to the newly created Flutter project: cd demo_project","title":"Step 2: Navigate to the Project Directory"},{"location":"9.1_how_to_git/#step-3-initialize-a-git-repository","text":"Initialize a new Git repository in your project directory: git init","title":"Step 3: Initialize a Git Repository"},{"location":"9.1_how_to_git/#step-4-add-files-to-git-and-make-initial-commit","text":"Add all the project files to the Git repository: git add . Make your initial commit: git commit -m \"Initial commit\"","title":"Step 4: Add Files to Git and Make Initial Commit"},{"location":"9.1_how_to_git/#step-5-link-to-github-repository","text":"Go to GitHub and create a new repository named demo_project . Copy the repository URL. Link your local repository to the GitHub repository: git remote add origin https://github.com/yourusername/demo_project.git","title":"Step 5: Link to GitHub Repository"},{"location":"9.1_how_to_git/#step-6-rename-the-default-branch-optional","text":"Rename your default branch to main (this is optional and based on your preference): git branch -M main","title":"Step 6: Rename the Default Branch (Optional)"},{"location":"9.1_how_to_git/#step-7-push-to-github","text":"Push your local repository to GitHub: git push -u origin main","title":"Step 7: Push to GitHub"},{"location":"9.1_how_to_git/#step-8-open-project-in-pycharm","text":"Open PyCharm. Go to File > Open . Navigate to your demo_project directory and select it. Click Open .","title":"Step 8: Open Project in PyCharm"},{"location":"9.2_analysis_options.yaml/","text":"Open another configuration file in the project, analysis_options.yaml . Replace its contents with the following: include : package:flutter_lints/flutter.yaml linter : rules : prefer_const_constructors : false prefer_final_fields : false use_key_in_widget_constructors : false prefer_const_literals_to_create_immutables : false prefer_const_constructors_in_immutables : false avoid_print : false This file determines how strict Flutter should be when analyzing your code. Since this is your first foray into Flutter, you're telling the analyzer to take it easy. You can always tune this later. In fact, as you get closer to publishing an actual production app, you will almost certainly want to make the analyzer stricter than this.","title":"B: Modify analysis_options.yaml to make it chill"},{"location":"L1_hello_flutter/","text":"Lecture 1 What is flutter Flutter is an open source framework by Google for building beautiful, natively compiled, multi-platform applications from a single codebase. Multi-Platform Flutter allows you to build apps for mobile, web, desktop, and embedded devices \u2014 all from a single codebase. Popular Flutter is the most popular cross platform application development framework according to the 2022 Stack Overflow developer survey","title":"Lecture 1"},{"location":"L1_hello_flutter/#lecture-1","text":"","title":"Lecture 1"},{"location":"L1_hello_flutter/#what-is-flutter","text":"Flutter is an open source framework by Google for building beautiful, natively compiled, multi-platform applications from a single codebase.","title":"What is flutter"},{"location":"L1_hello_flutter/#multi-platform","text":"Flutter allows you to build apps for mobile, web, desktop, and embedded devices \u2014 all from a single codebase.","title":"Multi-Platform"},{"location":"L1_hello_flutter/#popular","text":"Flutter is the most popular cross platform application development framework according to the 2022 Stack Overflow developer survey","title":"Popular"},{"location":"L2_getting_started/","text":"Plan Lec 2","title":"Plan Lec 2"},{"location":"L2_getting_started/#plan-lec-2","text":"","title":"Plan Lec 2"},{"location":"admin/","text":"COMP 4768: Software Development for Mobile Devices Instructor: Pranjal Patra Office: EN2008 Email: pp7002@mun.ca Office Hours: Fridays 2PM to 4PM or by request (virtual meetings) Evaluation Assignments (4 - 5): 50% Project: 50%","title":"COMP 4768: Software Development for Mobile Devices"},{"location":"admin/#comp-4768-software-development-for-mobile-devices","text":"","title":"COMP 4768: Software Development for Mobile Devices"},{"location":"admin/#instructor-pranjal-patra","text":"Office: EN2008 Email: pp7002@mun.ca Office Hours: Fridays 2PM to 4PM or by request (virtual meetings)","title":"Instructor: Pranjal Patra"},{"location":"admin/#evaluation","text":"Assignments (4 - 5): 50% Project: 50%","title":"Evaluation"},{"location":"recipes/","text":"Quick Meat and Veggie Pasta Ingredients 1 onion, sliced 1 bell pepper, sliced Salt and pepper to taste 2 garlic cloves, minced 1 lb ground meat (beef, turkey, or pork) Splash of red wine 1 cup pasata (tomato puree) Parmesan cheese, grated Cooked noodles Instructions Saut\u00e9 Veggies : In a pan, fry onions and bell peppers with salt and pepper. Add Garlic : Stir in minced garlic and continue frying. Cook Meat : Add ground meat to the pan and cook until browned. Deglaze : Add a splash of red wine to deglaze the pan. Add Pasata : Stir in pasata and simmer for a few minutes. Cheese : Mix in grated Parmesan cheese. Serve : Eat the sauce over cooked noodles. Enjoy your quick and delicious meal! Quick Pad Thai Ingredients 1 cup shrimp or 2 chicken breasts, sliced 1 egg Bean sprouts, onions, peppers, carrots 2 portions wide rice noodles Lime wedge Crushed peanuts, spring onions 1 jar Pad Thai sauce Instructions Cook Meat : Heat oil in a pan. Stir-fry shrimp or chicken until cooked. Add Egg : Make space in pan, crack in egg. Scramble with meat. Add Veggies and Sauce : Toss in veggies and sauce. Cook 1 min. Add Noodles : Mix in cooked noodles. Garnish : Top with peanuts, spring onions, and lime squeeze. Enjoy!","title":"Quick Meat and Veggie Pasta"},{"location":"recipes/#quick-meat-and-veggie-pasta","text":"","title":"Quick Meat and Veggie Pasta"},{"location":"recipes/#ingredients","text":"1 onion, sliced 1 bell pepper, sliced Salt and pepper to taste 2 garlic cloves, minced 1 lb ground meat (beef, turkey, or pork) Splash of red wine 1 cup pasata (tomato puree) Parmesan cheese, grated Cooked noodles","title":"Ingredients"},{"location":"recipes/#instructions","text":"Saut\u00e9 Veggies : In a pan, fry onions and bell peppers with salt and pepper. Add Garlic : Stir in minced garlic and continue frying. Cook Meat : Add ground meat to the pan and cook until browned. Deglaze : Add a splash of red wine to deglaze the pan. Add Pasata : Stir in pasata and simmer for a few minutes. Cheese : Mix in grated Parmesan cheese. Serve : Eat the sauce over cooked noodles. Enjoy your quick and delicious meal!","title":"Instructions"},{"location":"recipes/#quick-pad-thai","text":"","title":"Quick Pad Thai"},{"location":"recipes/#ingredients_1","text":"1 cup shrimp or 2 chicken breasts, sliced 1 egg Bean sprouts, onions, peppers, carrots 2 portions wide rice noodles Lime wedge Crushed peanuts, spring onions 1 jar Pad Thai sauce","title":"Ingredients"},{"location":"recipes/#instructions_1","text":"Cook Meat : Heat oil in a pan. Stir-fry shrimp or chicken until cooked. Add Egg : Make space in pan, crack in egg. Scramble with meat. Add Veggies and Sauce : Toss in veggies and sauce. Cook 1 min. Add Noodles : Mix in cooked noodles. Garnish : Top with peanuts, spring onions, and lime squeeze. Enjoy!","title":"Instructions"}]}